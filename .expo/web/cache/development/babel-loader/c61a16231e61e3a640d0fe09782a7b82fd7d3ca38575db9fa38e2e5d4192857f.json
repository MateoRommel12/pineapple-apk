{"ast":null,"code":"import { getApp, initializeAuth, getReactNativePersistence, onAuthStateChanged, onIdTokenChanged, signInAnonymously, sendSignInLinkToEmail, getAdditionalUserInfo, multiFactor, createUserWithEmailAndPassword, signInWithEmailAndPassword, signInWithEmailLink, signInWithCustomToken, sendPasswordResetEmail, useDeviceLanguage, verifyPasswordResetCode, connectAuthEmulator, fetchSignInMethodsForEmail, sendEmailVerification, verifyBeforeUpdateEmail, confirmPasswordReset, updateEmail, updatePassword, updateProfile, updatePhoneNumber, signInWithCredential, unlink, linkWithCredential, reauthenticateWithCredential, getIdToken, getIdTokenResult, applyActionCode, checkActionCode, EmailAuthProvider, FacebookAuthProvider, GoogleAuthProvider, TwitterAuthProvider, GithubAuthProvider, PhoneAuthProvider, OAuthProvider } from '@react-native-firebase/app/lib/internal/web/firebaseAuth';\nimport { guard, getWebError, emitEvent } from '@react-native-firebase/app/lib/internal/web/utils';\nimport { getReactNativeAsyncStorageInternal, isMemoryStorage } from '@react-native-firebase/app/lib/internal/asyncStorage';\nfunction promiseNoUser(isError = false) {\n  if (isError) {\n    return rejectPromiseWithCodeAndMessage('no-current-user', 'No user currently signed in.');\n  }\n  return Promise.resolve(null);\n}\nfunction rejectPromiseWithCodeAndMessage(code, message) {\n  return rejectPromise(getWebError({\n    code: `auth/${code}`,\n    message\n  }));\n}\nfunction rejectPromise(error) {\n  const {\n    code,\n    message,\n    details\n  } = error;\n  const nativeError = {\n    code,\n    message,\n    userInfo: {\n      code: code ? code.replace('auth/', '') : 'unknown',\n      message,\n      details\n    }\n  };\n  return Promise.reject(nativeError);\n}\nfunction userToObject(user) {\n  return Object.assign({}, userInfoToObject(user), {\n    emailVerified: user.emailVerified,\n    isAnonymous: user.isAnonymous,\n    tenantId: user.tenantId !== null && user.tenantId !== '' ? user.tenantId : null,\n    providerData: user.providerData.map(userInfoToObject),\n    metadata: userMetadataToObject(user.metadata),\n    multiFactor: multiFactor(user).enrolledFactors.map(multiFactorInfoToObject)\n  });\n}\nfunction getAuthCredential(_auth, provider, token, secret) {\n  if (provider.startsWith('oidc.')) {\n    return new OAuthProvider(provider).credential({\n      idToken: token\n    });\n  }\n  switch (provider) {\n    case 'facebook.com':\n      return FacebookAuthProvider().credential(token);\n    case 'google.com':\n      return GoogleAuthProvider().credential(token, secret);\n    case 'twitter.com':\n      return TwitterAuthProvider().credential(token, secret);\n    case 'github.com':\n      return GithubAuthProvider().credential(token);\n    case 'apple.com':\n      return new OAuthProvider(provider).credential({\n        idToken: token,\n        rawNonce: secret\n      });\n    case 'oauth':\n      return OAuthProvider(provider).credential({\n        idToken: token,\n        accessToken: secret\n      });\n    case 'phone':\n      return PhoneAuthProvider.credential(token, secret);\n    case 'password':\n      return EmailAuthProvider.credential(token, secret);\n    case 'emailLink':\n      return EmailAuthProvider.credentialWithLink(token, secret);\n    default:\n      return null;\n  }\n}\nfunction userInfoToObject(userInfo) {\n  return {\n    providerId: userInfo.providerId,\n    uid: userInfo.uid,\n    displayName: userInfo.displayName !== null && userInfo.displayName !== '' ? userInfo.displayName : null,\n    email: userInfo.email !== null && userInfo.email !== '' ? userInfo.email : null,\n    photoURL: userInfo.photoURL !== null && userInfo.photoURL !== '' ? userInfo.photoURL : null,\n    phoneNumber: userInfo.phoneNumber !== null && userInfo.phoneNumber !== '' ? userInfo.phoneNumber : null\n  };\n}\nfunction userMetadataToObject(metadata) {\n  return {\n    creationTime: metadata.creationTime ? new Date(metadata.creationTime).toISOString() : null,\n    lastSignInTime: metadata.lastSignInTime ? new Date(metadata.lastSignInTime).toISOString() : null\n  };\n}\nfunction multiFactorInfoToObject(multiFactorInfo) {\n  const obj = {\n    displayName: multiFactorInfo.displayName,\n    enrollmentTime: multiFactorInfo.enrollmentTime,\n    factorId: multiFactorInfo.factorId,\n    uid: multiFactorInfo.uid\n  };\n  if ('phoneNumber' in multiFactorInfo) {\n    obj.phoneNumber = multiFactorInfo.phoneNumber;\n  }\n  return obj;\n}\nfunction authResultToObject(userCredential) {\n  const additional = getAdditionalUserInfo(userCredential);\n  return {\n    user: userToObject(userCredential.user),\n    additionalUserInfo: {\n      isNewUser: additional.isNewUser,\n      profile: additional.profile,\n      providerId: additional.providerId,\n      username: additional.username\n    }\n  };\n}\nconst instances = {};\nconst authStateListeners = {};\nconst idTokenListeners = {};\nconst sessionMap = new Map();\nlet sessionId = 0;\nfunction getCachedAuthInstance(appName) {\n  if (!instances[appName]) {\n    if (!isMemoryStorage()) {\n      console.warn(```\nFirebase Auth persistence is disabled. To enable persistence, provide an Async Storage implementation.\n\nFor example, to use React Native Async Storage:\n\n  import AsyncStorage from '@react-native-async-storage/async-storage';\n\n  // Before initializing Firebase set the Async Storage implementation\n  // that will be used to persist user sessions.\n  firebase.setReactNativeAsyncStorage(AsyncStorage);\n\n  // Then initialize Firebase as normal.\n  await firebase.initializeApp({ ... });\n```);\n    }\n    instances[appName] = initializeAuth(getApp(appName), {\n      persistence: getReactNativePersistence(getReactNativeAsyncStorageInternal())\n    });\n  }\n  return instances[appName];\n}\nconst CONSTANTS = {\n  APP_LANGUAGE: {},\n  APP_USER: {}\n};\nexport default Object.assign({}, CONSTANTS, {\n  async useUserAccessGroup() {},\n  configureAuthDomain() {\n    return rejectPromiseWithCodeAndMessage('unsupported', 'This operation is not supported in this environment.');\n  },\n  async getCustomAuthDomain() {\n    return rejectPromiseWithCodeAndMessage('unsupported', 'This operation is not supported in this environment.');\n  },\n  addAuthStateListener(appName) {\n    if (authStateListeners[appName]) {\n      return;\n    }\n    return guard(async () => {\n      const auth = getCachedAuthInstance(appName);\n      authStateListeners[appName] = onAuthStateChanged(auth, user => {\n        emitEvent('auth_state_changed', {\n          appName,\n          user: user ? userToObject(user) : null\n        });\n      });\n    });\n  },\n  removeAuthStateListener(appName) {\n    if (authStateListeners[appName]) {\n      authStateListeners[appName]();\n      delete authStateListeners[appName];\n    }\n  },\n  addIdTokenListener(appName) {\n    if (idTokenListeners[appName]) {\n      return;\n    }\n    return guard(async () => {\n      const auth = getCachedAuthInstance(appName);\n      idTokenListeners[appName] = onIdTokenChanged(auth, user => {\n        emitEvent('auth_id_token_changed', {\n          authenticated: !!user,\n          appName,\n          user: user ? userToObject(user) : null\n        });\n      });\n    });\n  },\n  removeIdTokenListener(appName) {\n    if (idTokenListeners[appName]) {\n      idTokenListeners[appName]();\n      delete idTokenListeners[appName];\n    }\n  },\n  async forceRecaptchaFlowForTesting() {\n    return rejectPromiseWithCodeAndMessage('unsupported', 'This operation is not supported in this environment.');\n  },\n  async setAutoRetrievedSmsCodeForPhoneNumber() {\n    return rejectPromiseWithCodeAndMessage('unsupported', 'This operation is not supported in this environment.');\n  },\n  async setAppVerificationDisabledForTesting() {\n    return rejectPromiseWithCodeAndMessage('unsupported', 'This operation is not supported in this environment.');\n  },\n  signOut(appName) {\n    return guard(async () => {\n      const auth = getCachedAuthInstance(appName);\n      if (auth.currentUser === null) {\n        return promiseNoUser(true);\n      }\n      await auth.signOut();\n      return promiseNoUser();\n    });\n  },\n  signInAnonymously(appName) {\n    return guard(async () => {\n      const auth = getCachedAuthInstance(appName);\n      const credential = await signInAnonymously(auth);\n      return authResultToObject(credential);\n    });\n  },\n  async createUserWithEmailAndPassword(appName, email, password) {\n    return guard(async () => {\n      const auth = getCachedAuthInstance(appName);\n      const credential = await createUserWithEmailAndPassword(auth, email, password);\n      return authResultToObject(credential);\n    });\n  },\n  async signInWithEmailAndPassword(appName, email, password) {\n    return guard(async () => {\n      const auth = getCachedAuthInstance(appName);\n      const credential = await signInWithEmailAndPassword(auth, email, password);\n      return authResultToObject(credential);\n    });\n  },\n  async signInWithEmailLink(appName, email, emailLink) {\n    return guard(async () => {\n      const auth = getCachedAuthInstance(appName);\n      const credential = await signInWithEmailLink(auth, email, emailLink);\n      return authResultToObject(credential);\n    });\n  },\n  async signInWithCustomToken(appName, token) {\n    return guard(async () => {\n      const auth = getCachedAuthInstance(appName);\n      const credential = await signInWithCustomToken(auth, token);\n      return authResultToObject(credential);\n    });\n  },\n  async revokeToken() {\n    return promiseNoUser();\n  },\n  async sendPasswordResetEmail(appName, email, settings) {\n    return guard(async () => {\n      const auth = getCachedAuthInstance(appName);\n      await sendPasswordResetEmail(auth, email, settings);\n      return promiseNoUser();\n    });\n  },\n  async sendSignInLinkToEmail(appName, email, settings) {\n    return guard(async () => {\n      const auth = getCachedAuthInstance(appName);\n      await sendSignInLinkToEmail(auth, email, settings);\n      return promiseNoUser();\n    });\n  },\n  async delete(appName) {\n    return guard(async () => {\n      const auth = getCachedAuthInstance(appName);\n      if (auth.currentUser === null) {\n        return promiseNoUser(true);\n      }\n      await auth.currentUser.delete();\n      return promiseNoUser();\n    });\n  },\n  async reload(appName) {\n    return guard(async () => {\n      const auth = getCachedAuthInstance(appName);\n      if (auth.currentUser === null) {\n        return promiseNoUser(true);\n      }\n      await auth.currentUser.reload();\n      return userToObject(auth.currentUser);\n    });\n  },\n  async sendEmailVerification(appName, actionCodeSettings) {\n    return guard(async () => {\n      const auth = getCachedAuthInstance(appName);\n      if (auth.currentUser === null) {\n        return promiseNoUser(true);\n      }\n      await sendEmailVerification(auth.currentUser, actionCodeSettings);\n      return userToObject(auth.currentUser);\n    });\n  },\n  async verifyBeforeUpdateEmail(appName, email, actionCodeSettings) {\n    return guard(async () => {\n      const auth = getCachedAuthInstance(appName);\n      if (auth.currentUser === null) {\n        return promiseNoUser(true);\n      }\n      await verifyBeforeUpdateEmail(auth.currentUser, email, actionCodeSettings);\n      return userToObject(auth.currentUser);\n    });\n  },\n  async updateEmail(appName, email) {\n    return guard(async () => {\n      const auth = getCachedAuthInstance(appName);\n      if (auth.currentUser === null) {\n        return promiseNoUser(true);\n      }\n      await updateEmail(auth.currentUser, email);\n      return userToObject(auth.currentUser);\n    });\n  },\n  async updatePassword(appName, password) {\n    return guard(async () => {\n      const auth = getCachedAuthInstance(appName);\n      if (auth.currentUser === null) {\n        return promiseNoUser(true);\n      }\n      await updatePassword(auth.currentUser, password);\n      return userToObject(auth.currentUser);\n    });\n  },\n  async updatePhoneNumber(appName, provider, authToken, authSecret) {\n    return guard(async () => {\n      const auth = getCachedAuthInstance(appName);\n      if (auth.currentUser === null) {\n        return promiseNoUser(true);\n      }\n      if (provider !== 'phone') {\n        return rejectPromiseWithCodeAndMessage('invalid-credential', 'The supplied auth credential does not have a phone provider.');\n      }\n      const credential = getAuthCredential(auth, provider, authToken, authSecret);\n      if (!credential) {\n        return rejectPromiseWithCodeAndMessage('invalid-credential', 'The supplied auth credential is malformed, has expired or is not currently supported.');\n      }\n      await updatePhoneNumber(auth.currentUser, credential);\n      return userToObject(auth.currentUser);\n    });\n  },\n  async updateProfile(appName, props) {\n    return guard(async () => {\n      const auth = getCachedAuthInstance(appName);\n      if (auth.currentUser === null) {\n        return promiseNoUser(true);\n      }\n      await updateProfile(auth.currentUser, {\n        displayName: props.displayName,\n        photoURL: props.photoURL\n      });\n      return userToObject(auth.currentUser);\n    });\n  },\n  async signInWithCredential(appName, provider, authToken, authSecret) {\n    return guard(async () => {\n      const auth = getCachedAuthInstance(appName);\n      const credential = getAuthCredential(auth, provider, authToken, authSecret);\n      if (credential === null) {\n        return rejectPromiseWithCodeAndMessage('invalid-credential', 'The supplied auth credential is malformed, has expired or is not currently supported.');\n      }\n      const credentialResult = await signInWithCredential(auth, credential);\n      return authResultToObject(credentialResult);\n    });\n  },\n  async signInWithProvider() {\n    return rejectPromiseWithCodeAndMessage('unsupported', 'This operation is not supported in this environment.');\n  },\n  async signInWithPhoneNumber() {\n    return rejectPromiseWithCodeAndMessage('unsupported', 'This operation is not supported in this environment.');\n  },\n  async getSession(appName) {\n    return guard(async () => {\n      const auth = getCachedAuthInstance(appName);\n      if (auth.currentUser === null) {\n        return promiseNoUser(true);\n      }\n      const session = await multiFactor(auth.currentUser).getSession();\n      sessionId++;\n      const key = `${sessionId}`;\n      sessionMap.set(key, session);\n      return key;\n    });\n  },\n  verifyPhoneNumberForMultiFactor() {\n    return rejectPromiseWithCodeAndMessage('unsupported', 'This operation is not supported in this environment.');\n  },\n  finalizeMultiFactorEnrollment() {\n    return rejectPromiseWithCodeAndMessage('unsupported', 'This operation is not supported in this environment.');\n  },\n  resolveMultiFactorSignIn() {\n    return rejectPromiseWithCodeAndMessage('unsupported', 'This operation is not supported in this environment.');\n  },\n  confirmationResultConfirm() {\n    return rejectPromiseWithCodeAndMessage('unsupported', 'This operation is not supported in this environment.');\n  },\n  verifyPhoneNumber() {\n    return rejectPromiseWithCodeAndMessage('unsupported', 'This operation is not supported in this environment.');\n  },\n  async confirmPasswordReset(appName, code, newPassword) {\n    return guard(async () => {\n      const auth = getCachedAuthInstance(appName);\n      await confirmPasswordReset(auth, code, newPassword);\n      return promiseNoUser();\n    });\n  },\n  async applyActionCode(appName, code) {\n    return guard(async () => {\n      const auth = getCachedAuthInstance(appName);\n      await applyActionCode(auth, code);\n    });\n  },\n  async checkActionCode(appName, code) {\n    return guard(async () => {\n      const auth = getCachedAuthInstance(appName);\n      const result = await checkActionCode(auth, code);\n      return {\n        operation: result.operation,\n        data: {\n          email: result.data.email,\n          fromEmail: result.data.previousEmail\n        }\n      };\n    });\n  },\n  async linkWithCredential(appName, provider, authToken, authSecret) {\n    return guard(async () => {\n      const auth = getCachedAuthInstance(appName);\n      const credential = getAuthCredential(auth, provider, authToken, authSecret);\n      if (credential === null) {\n        return rejectPromiseWithCodeAndMessage('invalid-credential', 'The supplied auth credential is malformed, has expired or is not currently supported.');\n      }\n      if (auth.currentUser === null) {\n        return promiseNoUser(true);\n      }\n      return authResultToObject(await linkWithCredential(auth.currentUser, credential));\n    });\n  },\n  async linkWithProvider() {\n    return rejectPromiseWithCodeAndMessage('unsupported', 'This operation is not supported in this environment.');\n  },\n  async unlink(appName, providerId) {\n    return guard(async () => {\n      const auth = getCachedAuthInstance(appName);\n      if (auth.currentUser === null) {\n        return promiseNoUser(true);\n      }\n      const user = await unlink(auth.currentUser, providerId);\n      return userToObject(user);\n    });\n  },\n  async reauthenticateWithCredential(appName, provider, authToken, authSecret) {\n    return guard(async () => {\n      const auth = getCachedAuthInstance(appName);\n      const credential = getAuthCredential(auth, provider, authToken, authSecret);\n      if (credential === null) {\n        return rejectPromiseWithCodeAndMessage('invalid-credential', 'The supplied auth credential is malformed, has expired or is not currently supported.');\n      }\n      if (auth.currentUser === null) {\n        return promiseNoUser(true);\n      }\n      return authResultToObject(await reauthenticateWithCredential(auth.currentUser, credential));\n    });\n  },\n  async reauthenticateWithProvider() {\n    return rejectPromiseWithCodeAndMessage('unsupported', 'This operation is not supported in this environment.');\n  },\n  async getIdToken(appName, forceRefresh) {\n    return guard(async () => {\n      const auth = getCachedAuthInstance(appName);\n      if (auth.currentUser === null) {\n        return promiseNoUser(true);\n      }\n      const token = await getIdToken(auth.currentUser, forceRefresh);\n      return token;\n    });\n  },\n  async getIdTokenResult(appName, forceRefresh) {\n    return guard(async () => {\n      const auth = getCachedAuthInstance(appName);\n      if (auth.currentUser === null) {\n        return promiseNoUser(true);\n      }\n      const result = await getIdTokenResult(auth.currentUser, forceRefresh);\n      return {\n        authTime: result.authTime,\n        expirationTime: result.expirationTime,\n        issuedAtTime: result.issuedAtTime,\n        claims: result.claims,\n        signInProvider: result.signInProvider,\n        token: result.token\n      };\n    });\n  },\n  async fetchSignInMethodsForEmail(appName, email) {\n    return guard(async () => {\n      const auth = getCachedAuthInstance(appName);\n      const methods = await fetchSignInMethodsForEmail(auth, email);\n      return methods;\n    });\n  },\n  setLanguageCode(appName, code) {\n    return guard(async () => {\n      const auth = getCachedAuthInstance(appName);\n      auth.languageCode = code;\n    });\n  },\n  setTenantId(appName, tenantId) {\n    return guard(async () => {\n      const auth = getCachedAuthInstance(appName);\n      auth.tenantId = tenantId;\n    });\n  },\n  useDeviceLanguage(appName) {\n    return guard(async () => {\n      const auth = getCachedAuthInstance(appName);\n      useDeviceLanguage(auth);\n    });\n  },\n  verifyPasswordResetCode(appName, code) {\n    return guard(async () => {\n      const auth = getCachedAuthInstance(appName);\n      const email = await verifyPasswordResetCode(auth, code);\n      return email;\n    });\n  },\n  useEmulator(appName, host, port) {\n    return guard(async () => {\n      const auth = getCachedAuthInstance(appName);\n      connectAuthEmulator(auth, `http://${host}:${port}`);\n    });\n  }\n});","map":{"version":3,"names":["getApp","initializeAuth","getReactNativePersistence","onAuthStateChanged","onIdTokenChanged","signInAnonymously","sendSignInLinkToEmail","getAdditionalUserInfo","multiFactor","createUserWithEmailAndPassword","signInWithEmailAndPassword","signInWithEmailLink","signInWithCustomToken","sendPasswordResetEmail","useDeviceLanguage","verifyPasswordResetCode","connectAuthEmulator","fetchSignInMethodsForEmail","sendEmailVerification","verifyBeforeUpdateEmail","confirmPasswordReset","updateEmail","updatePassword","updateProfile","updatePhoneNumber","signInWithCredential","unlink","linkWithCredential","reauthenticateWithCredential","getIdToken","getIdTokenResult","applyActionCode","checkActionCode","EmailAuthProvider","FacebookAuthProvider","GoogleAuthProvider","TwitterAuthProvider","GithubAuthProvider","PhoneAuthProvider","OAuthProvider","guard","getWebError","emitEvent","getReactNativeAsyncStorageInternal","isMemoryStorage","promiseNoUser","isError","rejectPromiseWithCodeAndMessage","Promise","resolve","code","message","rejectPromise","error","details","nativeError","userInfo","replace","reject","userToObject","user","Object","assign","userInfoToObject","emailVerified","isAnonymous","tenantId","providerData","map","metadata","userMetadataToObject","enrolledFactors","multiFactorInfoToObject","getAuthCredential","_auth","provider","token","secret","startsWith","credential","idToken","rawNonce","accessToken","credentialWithLink","providerId","uid","displayName","email","photoURL","phoneNumber","creationTime","Date","toISOString","lastSignInTime","multiFactorInfo","obj","enrollmentTime","factorId","authResultToObject","userCredential","additional","additionalUserInfo","isNewUser","profile","username","instances","authStateListeners","idTokenListeners","sessionMap","Map","sessionId","getCachedAuthInstance","appName","console","warn","persistence","CONSTANTS","APP_LANGUAGE","APP_USER","useUserAccessGroup","configureAuthDomain","getCustomAuthDomain","addAuthStateListener","auth","removeAuthStateListener","addIdTokenListener","authenticated","removeIdTokenListener","forceRecaptchaFlowForTesting","setAutoRetrievedSmsCodeForPhoneNumber","setAppVerificationDisabledForTesting","signOut","currentUser","password","emailLink","revokeToken","settings","delete","reload","actionCodeSettings","authToken","authSecret","props","credentialResult","signInWithProvider","signInWithPhoneNumber","getSession","session","key","set","verifyPhoneNumberForMultiFactor","finalizeMultiFactorEnrollment","resolveMultiFactorSignIn","confirmationResultConfirm","verifyPhoneNumber","newPassword","result","operation","data","fromEmail","previousEmail","linkWithProvider","reauthenticateWithProvider","forceRefresh","authTime","expirationTime","issuedAtTime","claims","signInProvider","methods","setLanguageCode","languageCode","setTenantId","useEmulator","host","port"],"sources":["C:/Users/ACER/Documents/Capstone/node_modules/@react-native-firebase/auth/lib/web/RNFBAuthModule.js"],"sourcesContent":["import {\n  getApp,\n  initializeAuth,\n  getReactNativePersistence,\n  onAuthStateChanged,\n  onIdTokenChanged,\n  signInAnonymously,\n  sendSignInLinkToEmail,\n  getAdditionalUserInfo,\n  multiFactor,\n  createUserWithEmailAndPassword,\n  signInWithEmailAndPassword,\n  signInWithEmailLink,\n  signInWithCustomToken,\n  sendPasswordResetEmail,\n  useDeviceLanguage,\n  verifyPasswordResetCode,\n  connectAuthEmulator,\n  fetchSignInMethodsForEmail,\n  sendEmailVerification,\n  verifyBeforeUpdateEmail,\n  confirmPasswordReset,\n  updateEmail,\n  updatePassword,\n  updateProfile,\n  updatePhoneNumber,\n  signInWithCredential,\n  unlink,\n  linkWithCredential,\n  reauthenticateWithCredential,\n  getIdToken,\n  getIdTokenResult,\n  applyActionCode,\n  checkActionCode,\n  EmailAuthProvider,\n  FacebookAuthProvider,\n  GoogleAuthProvider,\n  TwitterAuthProvider,\n  GithubAuthProvider,\n  PhoneAuthProvider,\n  OAuthProvider,\n} from '@react-native-firebase/app/lib/internal/web/firebaseAuth';\nimport { guard, getWebError, emitEvent } from '@react-native-firebase/app/lib/internal/web/utils';\nimport {\n  getReactNativeAsyncStorageInternal,\n  isMemoryStorage,\n} from '@react-native-firebase/app/lib/internal/asyncStorage';\n\n/**\n * Resolves or rejects an auth method promise without a user (user was missing).\n * @param {boolean} isError whether to reject the promise.\n * @returns {Promise<void>} - Void promise.\n */\nfunction promiseNoUser(isError = false) {\n  if (isError) {\n    return rejectPromiseWithCodeAndMessage('no-current-user', 'No user currently signed in.');\n  }\n\n  // TODO(ehesp): Should this be null, or undefined?\n  return Promise.resolve(null);\n}\n\n/**\n * Returns a structured error object.\n * @param {string} code - The error code.\n * @param {string} message - The error message.\n */\nfunction rejectPromiseWithCodeAndMessage(code, message) {\n  return rejectPromise(getWebError({ code: `auth/${code}`, message }));\n}\n\n/**\n * Returns a structured error object.\n * @param {error} error The error object.\n * @returns {never}\n */\nfunction rejectPromise(error) {\n  const { code, message, details } = error;\n  const nativeError = {\n    code,\n    message,\n    userInfo: {\n      code: code ? code.replace('auth/', '') : 'unknown',\n      message,\n      details,\n    },\n  };\n  return Promise.reject(nativeError);\n}\n\n/**\n * Converts a user object to a plain object.\n * @param {User} user - The User object to convert.\n * @returns {object}\n */\nfunction userToObject(user) {\n  return {\n    ...userInfoToObject(user),\n    emailVerified: user.emailVerified,\n    isAnonymous: user.isAnonymous,\n    tenantId: user.tenantId !== null && user.tenantId !== '' ? user.tenantId : null,\n    providerData: user.providerData.map(userInfoToObject),\n    metadata: userMetadataToObject(user.metadata),\n    multiFactor: multiFactor(user).enrolledFactors.map(multiFactorInfoToObject),\n  };\n}\n\n/**\n * Returns an AuthCredential object for the given provider.\n * @param {Auth} auth - The Auth instance to use.\n * @param {string} provider - The provider to get the credential for.\n * @param {string} token - The token to use for the credential.\n * @param {string|null} secret - The secret to use for the credential.\n * @returns {AuthCredential|null} - The AuthCredential object.\n */\nfunction getAuthCredential(_auth, provider, token, secret) {\n  if (provider.startsWith('oidc.')) {\n    return new OAuthProvider(provider).credential({\n      idToken: token,\n    });\n  }\n\n  switch (provider) {\n    case 'facebook.com':\n      return FacebookAuthProvider().credential(token);\n    case 'google.com':\n      return GoogleAuthProvider().credential(token, secret);\n    case 'twitter.com':\n      return TwitterAuthProvider().credential(token, secret);\n    case 'github.com':\n      return GithubAuthProvider().credential(token);\n    case 'apple.com':\n      return new OAuthProvider(provider).credential({\n        idToken: token,\n        rawNonce: secret,\n      });\n    case 'oauth':\n      return OAuthProvider(provider).credential({\n        idToken: token,\n        accessToken: secret,\n      });\n    case 'phone':\n      return PhoneAuthProvider.credential(token, secret);\n    case 'password':\n      return EmailAuthProvider.credential(token, secret);\n    case 'emailLink':\n      return EmailAuthProvider.credentialWithLink(token, secret);\n    default:\n      return null;\n  }\n}\n\n/**\n * Converts a user info object to a plain object.\n * @param {UserInfo} userInfo - The UserInfo object to convert.\n */\nfunction userInfoToObject(userInfo) {\n  return {\n    providerId: userInfo.providerId,\n    uid: userInfo.uid,\n    displayName:\n      userInfo.displayName !== null && userInfo.displayName !== '' ? userInfo.displayName : null,\n    email: userInfo.email !== null && userInfo.email !== '' ? userInfo.email : null,\n    photoURL: userInfo.photoURL !== null && userInfo.photoURL !== '' ? userInfo.photoURL : null,\n    phoneNumber:\n      userInfo.phoneNumber !== null && userInfo.phoneNumber !== '' ? userInfo.phoneNumber : null,\n  };\n}\n\n/**\n * Converts a user metadata object to a plain object.\n * @param {UserMetadata} metadata - The UserMetadata object to convert.\n */\nfunction userMetadataToObject(metadata) {\n  return {\n    creationTime: metadata.creationTime ? new Date(metadata.creationTime).toISOString() : null,\n    lastSignInTime: metadata.lastSignInTime\n      ? new Date(metadata.lastSignInTime).toISOString()\n      : null,\n  };\n}\n\n/**\n * Converts a MultiFactorInfo object to a plain object.\n * @param {MultiFactorInfo} multiFactorInfo - The MultiFactorInfo object to convert.\n */\nfunction multiFactorInfoToObject(multiFactorInfo) {\n  const obj = {\n    displayName: multiFactorInfo.displayName,\n    enrollmentTime: multiFactorInfo.enrollmentTime,\n    factorId: multiFactorInfo.factorId,\n    uid: multiFactorInfo.uid,\n  };\n\n  // If https://firebase.google.com/docs/reference/js/auth.phonemultifactorinfo\n  if ('phoneNumber' in multiFactorInfo) {\n    obj.phoneNumber = multiFactorInfo.phoneNumber;\n  }\n\n  return obj;\n}\n\n/**\n * Converts a user credential object to a plain object.\n * @param {UserCredential} userCredential - The user credential object to convert.\n */\nfunction authResultToObject(userCredential) {\n  const additional = getAdditionalUserInfo(userCredential);\n  return {\n    user: userToObject(userCredential.user),\n    additionalUserInfo: {\n      isNewUser: additional.isNewUser,\n      profile: additional.profile,\n      providerId: additional.providerId,\n      username: additional.username,\n    },\n  };\n}\n\nconst instances = {};\nconst authStateListeners = {};\nconst idTokenListeners = {};\nconst sessionMap = new Map();\nlet sessionId = 0;\n\n// Returns a cached Firestore instance.\nfunction getCachedAuthInstance(appName) {\n  if (!instances[appName]) {\n    if (!isMemoryStorage()) {\n      // Warn auth persistence is is disabled unless Async Storage implementation is provided.\n      // eslint-disable-next-line no-console\n      console.warn(\n        ```\nFirebase Auth persistence is disabled. To enable persistence, provide an Async Storage implementation.\n\nFor example, to use React Native Async Storage:\n\n  import AsyncStorage from '@react-native-async-storage/async-storage';\n\n  // Before initializing Firebase set the Async Storage implementation\n  // that will be used to persist user sessions.\n  firebase.setReactNativeAsyncStorage(AsyncStorage);\n\n  // Then initialize Firebase as normal.\n  await firebase.initializeApp({ ... });\n```,\n      );\n    }\n    instances[appName] = initializeAuth(getApp(appName), {\n      persistence: getReactNativePersistence(getReactNativeAsyncStorageInternal()),\n    });\n  }\n  return instances[appName];\n}\n\n// getConstants\nconst CONSTANTS = {\n  APP_LANGUAGE: {},\n  APP_USER: {},\n};\n\n// Not required for web, since it's dynamic initialization\n// and we are not making instances of auth based on apps that already exist\n// since there are none that exist before we initialize them in our code below.\n// for (const appName of getApps()) {\n//   const instance = getAuth(getApp(appName));\n//   CONSTANTS.APP_LANGUAGE[appName] = instance.languageCode;\n//   if (instance.currentUser) {\n//     CONSTANTS.APP_USER[appName] = userToObject(instance.currentUser);\n//   }\n// }\n\n/**\n * This is a 'NativeModule' for the web platform.\n * Methods here are identical to the ones found in\n * the native android/ios modules e.g. `@ReactMethod` annotated\n * java methods on Android.\n */\nexport default {\n  // Expose all the constants.\n  ...CONSTANTS,\n\n  async useUserAccessGroup() {\n    // noop\n  },\n\n  configureAuthDomain() {\n    return rejectPromiseWithCodeAndMessage(\n      'unsupported',\n      'This operation is not supported in this environment.',\n    );\n  },\n\n  async getCustomAuthDomain() {\n    return rejectPromiseWithCodeAndMessage(\n      'unsupported',\n      'This operation is not supported in this environment.',\n    );\n  },\n\n  /**\n   * Create a new auth state listener instance for a given app.\n   * @param {string} appName - The name of the app to get the auth instance for.\n   * @returns {Promise<void>} - Void promise.\n   */\n  addAuthStateListener(appName) {\n    if (authStateListeners[appName]) {\n      return;\n    }\n\n    return guard(async () => {\n      const auth = getCachedAuthInstance(appName);\n\n      authStateListeners[appName] = onAuthStateChanged(auth, user => {\n        emitEvent('auth_state_changed', {\n          appName,\n          user: user ? userToObject(user) : null,\n        });\n      });\n    });\n  },\n\n  /**\n   * Remove an auth state listener instance for a given app.\n   * @param {string} appName - The name of the app to get the auth instance for.\n   * @returns {Promise<void>} - Void promise.\n   */\n  removeAuthStateListener(appName) {\n    if (authStateListeners[appName]) {\n      authStateListeners[appName]();\n      delete authStateListeners[appName];\n    }\n  },\n\n  /**\n   * Create a new ID token listener instance for a given app.\n   * @param {string} appName - The name of the app to get the auth instance for.\n   * @returns {Promise<void>} - Void promise.\n   */\n  addIdTokenListener(appName) {\n    if (idTokenListeners[appName]) {\n      return;\n    }\n\n    return guard(async () => {\n      const auth = getCachedAuthInstance(appName);\n\n      idTokenListeners[appName] = onIdTokenChanged(auth, user => {\n        emitEvent('auth_id_token_changed', {\n          authenticated: !!user,\n          appName,\n          user: user ? userToObject(user) : null,\n        });\n      });\n    });\n  },\n\n  /**\n   * Remove an ID token listener instance for a given app.\n   * @param {string} appName - The name of the app to get the auth instance for.\n   * @returns {Promise<void>} - Void promise.\n   */\n  removeIdTokenListener(appName) {\n    if (idTokenListeners[appName]) {\n      idTokenListeners[appName]();\n      delete idTokenListeners[appName];\n    }\n  },\n\n  async forceRecaptchaFlowForTesting() {\n    return rejectPromiseWithCodeAndMessage(\n      'unsupported',\n      'This operation is not supported in this environment.',\n    );\n  },\n\n  async setAutoRetrievedSmsCodeForPhoneNumber() {\n    return rejectPromiseWithCodeAndMessage(\n      'unsupported',\n      'This operation is not supported in this environment.',\n    );\n  },\n\n  async setAppVerificationDisabledForTesting() {\n    return rejectPromiseWithCodeAndMessage(\n      'unsupported',\n      'This operation is not supported in this environment.',\n    );\n  },\n\n  /**\n   * Sign out the current user.\n   * @param {string} appName - The name of the app to get the auth instance for.\n   * @returns {Promise<void>} - Void promise.\n   */\n  signOut(appName) {\n    return guard(async () => {\n      const auth = getCachedAuthInstance(appName);\n\n      if (auth.currentUser === null) {\n        return promiseNoUser(true);\n      }\n\n      await auth.signOut();\n      return promiseNoUser();\n    });\n  },\n\n  /**\n   * Sign in anonymously.\n   * @param {*} appName - The name of the app to get the auth instance for.\n   * @returns\n   */\n  signInAnonymously(appName) {\n    return guard(async () => {\n      const auth = getCachedAuthInstance(appName);\n      const credential = await signInAnonymously(auth);\n      return authResultToObject(credential);\n    });\n  },\n\n  /**\n   * Sign in with email and password.\n   * @param {string} appName - The name of the app to get the auth instance for.\n   * @param {string} email - The email to sign in with.\n   * @param {string} password - The password to sign in with.\n   * @returns {Promise<object>} - The result of the sign in.\n   */\n  async createUserWithEmailAndPassword(appName, email, password) {\n    return guard(async () => {\n      const auth = getCachedAuthInstance(appName);\n      const credential = await createUserWithEmailAndPassword(auth, email, password);\n      return authResultToObject(credential);\n    });\n  },\n\n  /**\n   * Sign in with email and password.\n   * @param {string} appName - The name of the app to get the auth instance for.\n   * @param {string} email - The email to sign in with.\n   * @param {string} password - The password to sign in with.\n   * @returns {Promise<object>} - The result of the sign in.\n   */\n  async signInWithEmailAndPassword(appName, email, password) {\n    return guard(async () => {\n      const auth = getCachedAuthInstance(appName);\n      const credential = await signInWithEmailAndPassword(auth, email, password);\n      return authResultToObject(credential);\n    });\n  },\n\n  /**\n   * Sign in with email link.\n   * @param {string} appName - The name of the app to get the auth instance for.\n   * @param {string} email - The email to sign in with.\n   * @param {string} emailLink - The email link to sign in with.\n   * @returns {Promise<object>} - The result of the sign in.\n   */\n  async signInWithEmailLink(appName, email, emailLink) {\n    return guard(async () => {\n      const auth = getCachedAuthInstance(appName);\n      const credential = await signInWithEmailLink(auth, email, emailLink);\n      return authResultToObject(credential);\n    });\n  },\n\n  /**\n   * Sign in with a custom token.\n   * @param {string} appName - The name of the app to get the auth instance for.\n   * @param {string} token - The token to sign in with.\n   * @returns {Promise<object>} - The result of the sign in.\n   */\n  async signInWithCustomToken(appName, token) {\n    return guard(async () => {\n      const auth = getCachedAuthInstance(appName);\n      const credential = await signInWithCustomToken(auth, token);\n      return authResultToObject(credential);\n    });\n  },\n\n  /**\n   * Not implemented on web.\n   */\n  async revokeToken() {\n    return promiseNoUser();\n  },\n\n  /**\n   * Send a password reset email.\n   * @param {string} appName - The name of the app to get the auth instance for.\n   * @param {string} email - The email to send the password reset email to.\n   * @param {ActionCodeSettings} settings - The settings to use for the password reset email.\n   * @returns {Promise<null>}\n   */\n  async sendPasswordResetEmail(appName, email, settings) {\n    return guard(async () => {\n      const auth = getCachedAuthInstance(appName);\n      await sendPasswordResetEmail(auth, email, settings);\n      return promiseNoUser();\n    });\n  },\n\n  /**\n   * Send a sign in link to an email.\n   * @param {string} appName - The name of the app to get the auth instance for.\n   * @param {string} email - The email to send the password reset email to.\n   * @param {ActionCodeSettings} settings - The settings to use for the password reset email.\n   * @returns {Promise<null>}\n   */\n  async sendSignInLinkToEmail(appName, email, settings) {\n    return guard(async () => {\n      const auth = getCachedAuthInstance(appName);\n      await sendSignInLinkToEmail(auth, email, settings);\n      return promiseNoUser();\n    });\n  },\n\n  /* ----------------------\n   *  .currentUser methods\n   * ---------------------- */\n\n  /**\n   * Delete the current user.\n   * @param {string} appName - The name of the app to get the auth instance for.\n   * @returns {Promise<null>}\n   */\n  async delete(appName) {\n    return guard(async () => {\n      const auth = getCachedAuthInstance(appName);\n\n      if (auth.currentUser === null) {\n        return promiseNoUser(true);\n      }\n\n      await auth.currentUser.delete();\n      return promiseNoUser();\n    });\n  },\n\n  /**\n   * Reload the current user.\n   * @param {string} appName - The name of the app to get the auth instance for.\n   * @returns {Promise<object>} - The current user object.\n   */\n  async reload(appName) {\n    return guard(async () => {\n      const auth = getCachedAuthInstance(appName);\n\n      if (auth.currentUser === null) {\n        return promiseNoUser(true);\n      }\n\n      await auth.currentUser.reload();\n      return userToObject(auth.currentUser);\n    });\n  },\n\n  /**\n   * Send a verification email to the current user.\n   * @param {string} appName - The name of the app to get the auth instance for.\n   * @param {ActionCodeSettings} actionCodeSettings - The settings to use for the email verification.\n   * @returns {Promise<object>} - The current user object.\n   */\n  async sendEmailVerification(appName, actionCodeSettings) {\n    return guard(async () => {\n      const auth = getCachedAuthInstance(appName);\n\n      if (auth.currentUser === null) {\n        return promiseNoUser(true);\n      }\n\n      await sendEmailVerification(auth.currentUser, actionCodeSettings);\n      return userToObject(auth.currentUser);\n    });\n  },\n\n  /**\n   * Verify the email before updating it.\n   * @param {string} appName - The name of the app to get the auth instance for.\n   * @param {string} email - The email to verify.\n   * @param {ActionCodeSettings} actionCodeSettings - The settings to use for the email verification.\n   * @returns {Promise<object>} - The current user object.\n   */\n  async verifyBeforeUpdateEmail(appName, email, actionCodeSettings) {\n    return guard(async () => {\n      const auth = getCachedAuthInstance(appName);\n\n      if (auth.currentUser === null) {\n        return promiseNoUser(true);\n      }\n\n      await verifyBeforeUpdateEmail(auth.currentUser, email, actionCodeSettings);\n      return userToObject(auth.currentUser);\n    });\n  },\n\n  /**\n   * Update the current user's email.\n   * @param {string} appName - The name of the app to get the auth instance for.\n   * @param {string} email - The email to update.\n   * @returns {Promise<object>} - The current user object.\n   */\n  async updateEmail(appName, email) {\n    return guard(async () => {\n      const auth = getCachedAuthInstance(appName);\n\n      if (auth.currentUser === null) {\n        return promiseNoUser(true);\n      }\n\n      await updateEmail(auth.currentUser, email);\n      return userToObject(auth.currentUser);\n    });\n  },\n\n  /**\n   * Update the current user's password.\n   * @param {string} appName - The name of the app to get the auth instance for.\n   * @param {string} password - The password to update.\n   * @returns {Promise<object>} - The current user object.\n   */\n  async updatePassword(appName, password) {\n    return guard(async () => {\n      const auth = getCachedAuthInstance(appName);\n\n      if (auth.currentUser === null) {\n        return promiseNoUser(true);\n      }\n\n      await updatePassword(auth.currentUser, password);\n      return userToObject(auth.currentUser);\n    });\n  },\n\n  /**\n   * Update the current user's phone number.\n   * @param {string} appName - The name of the app to get the auth instance for.\n   * @param {string} provider - The provider to update the phone number with.\n   * @param {string} authToken - The auth token to update the phone number with.\n   * @param {string} authSecret - The auth secret to update the phone number with.\n   * @returns {Promise<object>} - The current user object.\n   */\n  async updatePhoneNumber(appName, provider, authToken, authSecret) {\n    return guard(async () => {\n      const auth = getCachedAuthInstance(appName);\n\n      if (auth.currentUser === null) {\n        return promiseNoUser(true);\n      }\n\n      if (provider !== 'phone') {\n        return rejectPromiseWithCodeAndMessage(\n          'invalid-credential',\n          'The supplied auth credential does not have a phone provider.',\n        );\n      }\n\n      const credential = getAuthCredential(auth, provider, authToken, authSecret);\n\n      if (!credential) {\n        return rejectPromiseWithCodeAndMessage(\n          'invalid-credential',\n          'The supplied auth credential is malformed, has expired or is not currently supported.',\n        );\n      }\n\n      await updatePhoneNumber(auth.currentUser, credential);\n\n      return userToObject(auth.currentUser);\n    });\n  },\n\n  /**\n   * Update the current user's profile.\n   * @param {string} appName - The name of the app to get the auth instance for.\n   * @param {object} props - The properties to update.\n   * @returns {Promise<object>} - The current user object.\n   */\n  async updateProfile(appName, props) {\n    return guard(async () => {\n      const auth = getCachedAuthInstance(appName);\n\n      if (auth.currentUser === null) {\n        return promiseNoUser(true);\n      }\n\n      await updateProfile(auth.currentUser, {\n        displayName: props.displayName,\n        photoURL: props.photoURL,\n      });\n\n      return userToObject(auth.currentUser);\n    });\n  },\n\n  /**\n   * Sign in with a credential.\n   * @param {string} appName - The name of the app to get the auth instance for.\n   * @param {string} provider - The provider to sign in with.\n   * @param {string} authToken - The auth token to sign in with.\n   * @param {string} authSecret - The auth secret to sign in with.\n   * @returns {Promise<object>} - The result of the sign in.\n   */\n  async signInWithCredential(appName, provider, authToken, authSecret) {\n    return guard(async () => {\n      const auth = getCachedAuthInstance(appName);\n      const credential = getAuthCredential(auth, provider, authToken, authSecret);\n\n      if (credential === null) {\n        return rejectPromiseWithCodeAndMessage(\n          'invalid-credential',\n          'The supplied auth credential is malformed, has expired or is not currently supported.',\n        );\n      }\n\n      const credentialResult = await signInWithCredential(auth, credential);\n      return authResultToObject(credentialResult);\n    });\n  },\n\n  async signInWithProvider() {\n    return rejectPromiseWithCodeAndMessage(\n      'unsupported',\n      'This operation is not supported in this environment.',\n    );\n  },\n\n  async signInWithPhoneNumber() {\n    return rejectPromiseWithCodeAndMessage(\n      'unsupported',\n      'This operation is not supported in this environment.',\n    );\n  },\n\n  /**\n   * Get a multi-factor session.\n   * @param {string} appName - The name of the app to get the auth instance for.\n   * @returns {Promise<string>} - The session ID.\n   */\n  async getSession(appName) {\n    return guard(async () => {\n      const auth = getCachedAuthInstance(appName);\n\n      if (auth.currentUser === null) {\n        return promiseNoUser(true);\n      }\n\n      const session = await multiFactor(auth.currentUser).getSession();\n\n      // Increment the session ID.\n      sessionId++;\n\n      const key = `${sessionId}`;\n      sessionMap.set(key, session);\n      return key;\n    });\n  },\n\n  verifyPhoneNumberForMultiFactor() {\n    return rejectPromiseWithCodeAndMessage(\n      'unsupported',\n      'This operation is not supported in this environment.',\n    );\n  },\n\n  finalizeMultiFactorEnrollment() {\n    return rejectPromiseWithCodeAndMessage(\n      'unsupported',\n      'This operation is not supported in this environment.',\n    );\n  },\n\n  resolveMultiFactorSignIn() {\n    return rejectPromiseWithCodeAndMessage(\n      'unsupported',\n      'This operation is not supported in this environment.',\n    );\n  },\n\n  confirmationResultConfirm() {\n    return rejectPromiseWithCodeAndMessage(\n      'unsupported',\n      'This operation is not supported in this environment.',\n    );\n  },\n\n  verifyPhoneNumber() {\n    return rejectPromiseWithCodeAndMessage(\n      'unsupported',\n      'This operation is not supported in this environment.',\n    );\n  },\n\n  /**\n   * Confirm the password reset code.\n   * @param {string} appName - The name of the app to get the auth instance for.\n   * @param {string} code - The code to confirm.\n   * @param {string} newPassword - The new password to set.\n   * @returns {Promise<null>}\n   */\n  async confirmPasswordReset(appName, code, newPassword) {\n    return guard(async () => {\n      const auth = getCachedAuthInstance(appName);\n      await confirmPasswordReset(auth, code, newPassword);\n      return promiseNoUser();\n    });\n  },\n\n  /**\n   * Apply an action code.\n   * @param {string} appName - The name of the app to get the auth instance for.\n   * @param {string} code - The code to apply.\n   * @returns {Promise<void>} - Void promise.\n   */\n  async applyActionCode(appName, code) {\n    return guard(async () => {\n      const auth = getCachedAuthInstance(appName);\n      await applyActionCode(auth, code);\n    });\n  },\n\n  /**\n   * Check an action code.\n   * @param {string} appName - The name of the app to get the auth instance for.\n   * @param {string} code - The code to check.\n   * @returns {Promise<object>} - The result of the check.\n   */\n  async checkActionCode(appName, code) {\n    return guard(async () => {\n      const auth = getCachedAuthInstance(appName);\n      const result = await checkActionCode(auth, code);\n\n      return {\n        operation: result.operation,\n        data: {\n          email: result.data.email,\n          fromEmail: result.data.previousEmail,\n          // multiFactorInfo - not implemented\n        },\n      };\n    });\n  },\n\n  /**\n   * Link a credential to the current user.\n   * @param {string} appName - The name of the app to get the auth instance for.\n   * @param {string} provider - The provider to link.\n   * @param {string} authToken - The auth token to link.\n   * @param {string} authSecret - The auth secret to link.\n   * @returns {Promise<object>} - The current user object.\n   */\n  async linkWithCredential(appName, provider, authToken, authSecret) {\n    return guard(async () => {\n      const auth = getCachedAuthInstance(appName);\n      const credential = getAuthCredential(auth, provider, authToken, authSecret);\n\n      if (credential === null) {\n        return rejectPromiseWithCodeAndMessage(\n          'invalid-credential',\n          'The supplied auth credential is malformed, has expired or is not currently supported.',\n        );\n      }\n\n      if (auth.currentUser === null) {\n        return promiseNoUser(true);\n      }\n\n      return authResultToObject(await linkWithCredential(auth.currentUser, credential));\n    });\n  },\n\n  async linkWithProvider() {\n    // TODO: We could check if window is available here, but for now it's not supported.\n    return rejectPromiseWithCodeAndMessage(\n      'unsupported',\n      'This operation is not supported in this environment.',\n    );\n  },\n\n  /**\n   * Unlink a provider from the current user.\n   * @param {string} appName - The name of the app to get the auth instance for.\n   * @param {string} providerId - The provider ID to unlink.\n   * @returns {Promise<object>} - The current user object.\n   */\n  async unlink(appName, providerId) {\n    return guard(async () => {\n      const auth = getCachedAuthInstance(appName);\n\n      if (auth.currentUser === null) {\n        return promiseNoUser(true);\n      }\n\n      const user = await unlink(auth.currentUser, providerId);\n      return userToObject(user);\n    });\n  },\n\n  /**\n   * Reauthenticate with a credential.\n   * @param {string} appName - The name of the app to get the auth instance for.\n   * @param {string} provider - The provider to reauthenticate with.\n   * @param {string} authToken - The auth token to reauthenticate with.\n   * @param {string} authSecret - The auth secret to reauthenticate with.\n   * @returns {Promise<object>} - The current user object.\n   */\n  async reauthenticateWithCredential(appName, provider, authToken, authSecret) {\n    return guard(async () => {\n      const auth = getCachedAuthInstance(appName);\n      const credential = getAuthCredential(auth, provider, authToken, authSecret);\n\n      if (credential === null) {\n        return rejectPromiseWithCodeAndMessage(\n          'invalid-credential',\n          'The supplied auth credential is malformed, has expired or is not currently supported.',\n        );\n      }\n\n      if (auth.currentUser === null) {\n        return promiseNoUser(true);\n      }\n\n      return authResultToObject(await reauthenticateWithCredential(auth.currentUser, credential));\n    });\n  },\n\n  async reauthenticateWithProvider() {\n    // TODO: We could check if window is available here, but for now it's not supported.\n    return rejectPromiseWithCodeAndMessage(\n      'unsupported',\n      'This operation is not supported in this environment.',\n    );\n  },\n\n  /**\n   * Get the ID token for the current user.\n   * @param {string} appName - The name of the app to get the auth instance for.\n   * @param {boolean} forceRefresh - Whether to force a token refresh.\n   * @returns {Promise<string>} - The ID token.\n   */\n  async getIdToken(appName, forceRefresh) {\n    return guard(async () => {\n      const auth = getCachedAuthInstance(appName);\n\n      if (auth.currentUser === null) {\n        return promiseNoUser(true);\n      }\n\n      const token = await getIdToken(auth.currentUser, forceRefresh);\n      return token;\n    });\n  },\n\n  /**\n   * Get the ID token result for the current user.\n   * @param {string} appName - The name of the app to get the auth instance for.\n   * @param {boolean} forceRefresh - Whether to force a token refresh.\n   * @returns {Promise<object>} - The ID token result.\n   */\n  async getIdTokenResult(appName, forceRefresh) {\n    return guard(async () => {\n      const auth = getCachedAuthInstance(appName);\n\n      if (auth.currentUser === null) {\n        return promiseNoUser(true);\n      }\n\n      const result = await getIdTokenResult(auth.currentUser, forceRefresh);\n\n      // TODO(ehesp): Result looks expected, might be safer to keep fixed object?\n      return {\n        authTime: result.authTime,\n        expirationTime: result.expirationTime,\n        issuedAtTime: result.issuedAtTime,\n        claims: result.claims,\n        signInProvider: result.signInProvider,\n        token: result.token,\n      };\n    });\n  },\n\n  /* ----------------------\n   *  other methods\n   * ---------------------- */\n\n  /**\n   * Fetch the sign in methods for an email.\n   * @param {string} appName - The name of the app to get the auth instance for.\n   * @param {string} email - The email to fetch the sign in methods for.\n   * @returns {Promise<string[]>} - The sign in methods for the email.\n   */\n  async fetchSignInMethodsForEmail(appName, email) {\n    return guard(async () => {\n      const auth = getCachedAuthInstance(appName);\n      const methods = await fetchSignInMethodsForEmail(auth, email);\n      return methods;\n    });\n  },\n\n  /**\n   * Set the language code.\n   * @param {string} appName - The name of the app to get the auth instance for.\n   * @param {string} code - The language code to set.\n   * @returns {void}\n   */\n  setLanguageCode(appName, code) {\n    return guard(async () => {\n      const auth = getCachedAuthInstance(appName);\n      auth.languageCode = code;\n    });\n  },\n\n  /**\n   * Set the tenant ID.\n   * @param {string} appName - The name of the app to get the auth instance for.\n   * @param {string} tenantId - The tenant ID to set.\n   * @returns {void}\n   */\n  setTenantId(appName, tenantId) {\n    return guard(async () => {\n      const auth = getCachedAuthInstance(appName);\n      auth.tenantId = tenantId;\n    });\n  },\n\n  /**\n   * Use the device language.\n   * @param {string} appName - The name of the app to get the auth instance for.\n   * @returns void\n   */\n  useDeviceLanguage(appName) {\n    return guard(async () => {\n      const auth = getCachedAuthInstance(appName);\n      useDeviceLanguage(auth);\n    });\n  },\n\n  /**\n   * Verify the provided password reset code.\n   * @returns {string} - The users email address if valid.\n   */\n  verifyPasswordResetCode(appName, code) {\n    return guard(async () => {\n      const auth = getCachedAuthInstance(appName);\n      const email = await verifyPasswordResetCode(auth, code);\n      return email;\n    });\n  },\n\n  /**\n   * Connect to the auth emulator.\n   * @param {string} appName - The name of the app to get the auth instance for.\n   * @param {string} host - The host to use for the auth emulator.\n   * @param {number} port - The port to use for the auth emulator.\n   * @returns {void}\n   */\n  useEmulator(appName, host, port) {\n    return guard(async () => {\n      const auth = getCachedAuthInstance(appName);\n      connectAuthEmulator(auth, `http://${host}:${port}`);\n    });\n  },\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{"hasCjsExports":false},"sourceType":"module","externalDependencies":[]}