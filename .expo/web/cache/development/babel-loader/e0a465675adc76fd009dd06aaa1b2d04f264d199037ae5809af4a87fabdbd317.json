{"ast":null,"code":"import _objectWithoutPropertiesLoose from \"@babel/runtime/helpers/objectWithoutPropertiesLoose\";\nconst _excluded = [\"language\", \"loginHint\", \"selectAccount\", \"extraParams\", \"clientSecret\"],\n  _excluded2 = [\"extraParams\"];\nimport * as Application from 'expo-application';\nimport { useEffect, useMemo, useState } from 'react';\nimport Platform from \"react-native-web/dist/exports/Platform\";\nimport { applyRequiredScopes, invariantClientId } from './ProviderUtils';\nimport { AuthRequest } from '../AuthRequest';\nimport { Prompt, ResponseType } from '../AuthRequest.types';\nimport { useAuthRequestResult, useLoadedAuthRequest } from '../AuthRequestHooks';\nimport { makeRedirectUri } from '../AuthSession';\nimport { generateHexStringAsync } from '../PKCE';\nimport { AccessTokenRequest } from '../TokenRequest';\nconst settings = {\n  windowFeatures: {\n    width: 515,\n    height: 680\n  },\n  minimumScopes: ['openid', 'https://www.googleapis.com/auth/userinfo.profile', 'https://www.googleapis.com/auth/userinfo.email']\n};\nexport const discovery = {\n  authorizationEndpoint: 'https://accounts.google.com/o/oauth2/v2/auth',\n  tokenEndpoint: 'https://oauth2.googleapis.com/token',\n  revocationEndpoint: 'https://oauth2.googleapis.com/revoke',\n  userInfoEndpoint: 'https://openidconnect.googleapis.com/v1/userinfo'\n};\nclass GoogleAuthRequest extends AuthRequest {\n  constructor(_ref) {\n    let {\n        language,\n        loginHint,\n        selectAccount,\n        extraParams = {},\n        clientSecret\n      } = _ref,\n      config = _objectWithoutPropertiesLoose(_ref, _excluded);\n    const inputParams = Object.assign({}, extraParams);\n    if (language) inputParams.hl = language;\n    if (loginHint) inputParams.login_hint = loginHint;\n    if (selectAccount) inputParams.prompt = Prompt.SelectAccount;\n    const scopes = applyRequiredScopes(config.scopes, settings.minimumScopes);\n    const isImplicit = config.responseType === ResponseType.Token || config.responseType === ResponseType.IdToken;\n    if (isImplicit) {\n      config.usePKCE = false;\n    }\n    let inputClientSecret;\n    if (config.responseType && config.responseType !== ResponseType.Code) {\n      inputClientSecret = clientSecret;\n    }\n    super(Object.assign({}, config, {\n      clientSecret: inputClientSecret,\n      scopes,\n      extraParams: inputParams\n    }));\n  }\n  async getAuthRequestConfigAsync() {\n    const _await$super$getAuthR = await super.getAuthRequestConfigAsync(),\n      {\n        extraParams = {}\n      } = _await$super$getAuthR,\n      config = _objectWithoutPropertiesLoose(_await$super$getAuthR, _excluded2);\n    if (config.responseType === ResponseType.IdToken && !extraParams.nonce && !this.nonce) {\n      if (!this.nonce) {\n        this.nonce = await generateHexStringAsync(16);\n      }\n      extraParams.nonce = this.nonce;\n    }\n    return Object.assign({}, config, {\n      extraParams\n    });\n  }\n}\nexport function useIdTokenAuthRequest(config, redirectUriOptions = {}) {\n  const isWebAuth = Platform.OS === 'web';\n  return useAuthRequest(Object.assign({}, config, {\n    responseType: !config.clientSecret && isWebAuth ? ResponseType.IdToken : undefined\n  }), Object.assign({}, redirectUriOptions));\n}\nexport function useAuthRequest(config = {}, redirectUriOptions = {}) {\n  const clientId = useMemo(() => {\n    const propertyName = Platform.select({\n      ios: 'iosClientId',\n      android: 'androidClientId',\n      default: 'webClientId'\n    });\n    const clientId = config[propertyName] ?? config.clientId;\n    invariantClientId(propertyName, clientId, 'Google');\n    return clientId;\n  }, [config.iosClientId, config.androidClientId, config.webClientId, config.clientId]);\n  const responseType = useMemo(() => {\n    if (typeof config.responseType !== 'undefined') {\n      return config.responseType;\n    }\n    const isInstalledApp = Platform.OS !== 'web';\n    if (config.clientSecret || isInstalledApp) {\n      return ResponseType.Code;\n    }\n    return ResponseType.Token;\n  }, [config.responseType, config.clientSecret]);\n  const redirectUri = useMemo(() => {\n    if (typeof config.redirectUri !== 'undefined') {\n      return config.redirectUri;\n    }\n    return makeRedirectUri(Object.assign({\n      native: `${Application.applicationId}:/oauthredirect`\n    }, redirectUriOptions));\n  }, [config.redirectUri, redirectUriOptions]);\n  const extraParams = useMemo(() => {\n    const output = config.extraParams ? Object.assign({}, config.extraParams) : {};\n    if (config.language) {\n      output.hl = output.language;\n    }\n    if (config.loginHint) {\n      output.login_hint = output.loginHint;\n    }\n    if (config.selectAccount) {\n      output.prompt = Prompt.SelectAccount;\n    }\n    return output;\n  }, [config.extraParams, config.language, config.loginHint, config.selectAccount]);\n  const request = useLoadedAuthRequest(Object.assign({}, config, {\n    responseType,\n    extraParams,\n    clientId,\n    redirectUri\n  }), discovery, GoogleAuthRequest);\n  const [result, promptAsync] = useAuthRequestResult(request, discovery, {\n    windowFeatures: settings.windowFeatures\n  });\n  const [fullResult, setFullResult] = useState(null);\n  const shouldAutoExchangeCode = useMemo(() => {\n    if (typeof config.shouldAutoExchangeCode !== 'undefined') {\n      return config.shouldAutoExchangeCode;\n    }\n    return result?.type === 'success' && result.params.code && !result.authentication;\n  }, [config.shouldAutoExchangeCode, result?.type]);\n  useEffect(() => {\n    let isMounted = true;\n    if (shouldAutoExchangeCode && result?.type === 'success') {\n      const exchangeRequest = new AccessTokenRequest({\n        clientId,\n        clientSecret: config.clientSecret,\n        redirectUri,\n        scopes: config.scopes,\n        code: result.params.code,\n        extraParams: {\n          code_verifier: request?.codeVerifier || ''\n        }\n      });\n      exchangeRequest.performAsync(discovery).then(authentication => {\n        if (isMounted) {\n          setFullResult(Object.assign({}, result, {\n            params: Object.assign({\n              id_token: authentication?.idToken || '',\n              access_token: authentication.accessToken\n            }, result.params),\n            authentication\n          }));\n        }\n      });\n    } else {\n      setFullResult(result);\n    }\n    return () => {\n      isMounted = false;\n    };\n  }, [clientId, redirectUri, shouldAutoExchangeCode, config.clientSecret, config.scopes?.join(','), request?.codeVerifier, result]);\n  return [request, fullResult, promptAsync];\n}","map":{"version":3,"names":["Application","useEffect","useMemo","useState","Platform","applyRequiredScopes","invariantClientId","AuthRequest","Prompt","ResponseType","useAuthRequestResult","useLoadedAuthRequest","makeRedirectUri","generateHexStringAsync","AccessTokenRequest","settings","windowFeatures","width","height","minimumScopes","discovery","authorizationEndpoint","tokenEndpoint","revocationEndpoint","userInfoEndpoint","GoogleAuthRequest","constructor","_ref","language","loginHint","selectAccount","extraParams","clientSecret","config","_objectWithoutPropertiesLoose","_excluded","inputParams","Object","assign","hl","login_hint","prompt","SelectAccount","scopes","isImplicit","responseType","Token","IdToken","usePKCE","inputClientSecret","Code","getAuthRequestConfigAsync","_await$super$getAuthR","_excluded2","nonce","useIdTokenAuthRequest","redirectUriOptions","isWebAuth","OS","useAuthRequest","undefined","clientId","propertyName","select","ios","android","default","iosClientId","androidClientId","webClientId","isInstalledApp","redirectUri","native","applicationId","output","request","result","promptAsync","fullResult","setFullResult","shouldAutoExchangeCode","type","params","code","authentication","isMounted","exchangeRequest","code_verifier","codeVerifier","performAsync","then","id_token","idToken","access_token","accessToken","join"],"sources":["C:\\Users\\ACER\\Documents\\Capstone\\node_modules\\expo-auth-session\\src\\providers\\Google.ts"],"sourcesContent":["import * as Application from 'expo-application';\nimport { useEffect, useMemo, useState } from 'react';\nimport { Platform } from 'react-native';\n\nimport { ProviderAuthRequestConfig } from './Provider.types';\nimport { applyRequiredScopes, invariantClientId } from './ProviderUtils';\nimport { AuthRequest } from '../AuthRequest';\nimport {\n  AuthRequestConfig,\n  AuthRequestPromptOptions,\n  Prompt,\n  ResponseType,\n} from '../AuthRequest.types';\nimport { useAuthRequestResult, useLoadedAuthRequest } from '../AuthRequestHooks';\nimport { makeRedirectUri } from '../AuthSession';\nimport { AuthSessionRedirectUriOptions, AuthSessionResult } from '../AuthSession.types';\nimport { DiscoveryDocument } from '../Discovery';\nimport { generateHexStringAsync } from '../PKCE';\nimport { AccessTokenRequest } from '../TokenRequest';\n\nconst settings = {\n  windowFeatures: { width: 515, height: 680 },\n  minimumScopes: [\n    'openid',\n    'https://www.googleapis.com/auth/userinfo.profile',\n    'https://www.googleapis.com/auth/userinfo.email',\n  ],\n};\n\nexport const discovery: DiscoveryDocument = {\n  authorizationEndpoint: 'https://accounts.google.com/o/oauth2/v2/auth',\n  tokenEndpoint: 'https://oauth2.googleapis.com/token',\n  revocationEndpoint: 'https://oauth2.googleapis.com/revoke',\n  userInfoEndpoint: 'https://openidconnect.googleapis.com/v1/userinfo',\n};\n\n// @needsAudit\n/**\n * @deprecated See [Google authentication](/guides/google-authentication/).\n */\nexport type GoogleAuthRequestConfig = ProviderAuthRequestConfig & {\n  /**\n   * If the user's email address is known ahead of time, it can be supplied to be the default option.\n   * If the user has approved access for this app in the past then auth may return without any further interaction.\n   */\n  loginHint?: string;\n  /**\n   * When `true`, the service will allow the user to switch between accounts (if possible).\n   * @default false.\n   */\n  selectAccount?: boolean;\n  /**\n   * Expo web client ID for use in the browser.\n   */\n  webClientId?: string;\n  /**\n   * iOS native client ID for use in standalone, bare workflow, and custom clients.\n   */\n  iosClientId?: string;\n  /**\n   * Android native client ID for use in standalone, and bare workflow.\n   */\n  androidClientId?: string;\n  /**\n   * Should the hook automatically exchange the response code for an authentication token.\n   *\n   * Defaults to `true` on installed apps (Android, iOS) when `ResponseType.Code` is used (default).\n   */\n  shouldAutoExchangeCode?: boolean;\n  /**\n   * Language code ISO 3166-1 alpha-2 region code, such as 'it' or 'pt-PT'.\n   */\n  language?: string;\n};\n\n// @needsAudit\n/**\n * Extends [`AuthRequest`](#authrequest) and accepts [`GoogleAuthRequestConfig`](#googleauthrequestconfig) in the constructor.\n */\nclass GoogleAuthRequest extends AuthRequest {\n  nonce?: string;\n\n  constructor({\n    language,\n    loginHint,\n    selectAccount,\n    extraParams = {},\n    clientSecret,\n    ...config\n  }: GoogleAuthRequestConfig) {\n    const inputParams = {\n      ...extraParams,\n    };\n    if (language) inputParams.hl = language;\n    if (loginHint) inputParams.login_hint = loginHint;\n    if (selectAccount) inputParams.prompt = Prompt.SelectAccount;\n\n    // Apply the default scopes\n    const scopes = applyRequiredScopes(config.scopes, settings.minimumScopes);\n    const isImplicit =\n      config.responseType === ResponseType.Token || config.responseType === ResponseType.IdToken;\n    if (isImplicit) {\n      // PKCE must be disabled in implicit mode.\n      config.usePKCE = false;\n    }\n    let inputClientSecret: string | undefined;\n    //  Google will throw if you attempt to use the client secret\n    if (config.responseType && config.responseType !== ResponseType.Code) {\n      // TODO: maybe warn that you shouldn't store the client secret on the client\n      inputClientSecret = clientSecret;\n    }\n    super({\n      ...config,\n      clientSecret: inputClientSecret,\n      scopes,\n      extraParams: inputParams,\n    });\n  }\n\n  /**\n   * Load and return a valid auth request based on the input config.\n   */\n  async getAuthRequestConfigAsync(): Promise<AuthRequestConfig> {\n    const { extraParams = {}, ...config } = await super.getAuthRequestConfigAsync();\n    if (config.responseType === ResponseType.IdToken && !extraParams.nonce && !this.nonce) {\n      if (!this.nonce) {\n        this.nonce = await generateHexStringAsync(16);\n      }\n      extraParams.nonce = this.nonce;\n    }\n    return {\n      ...config,\n      extraParams,\n    };\n  }\n}\n\n/**\n * Load an authorization request with an ID Token for authentication with Firebase.\n *\n * Returns a loaded request, a response, and a prompt method.\n * When the prompt method completes then the response will be fulfilled.\n *\n * The id token can be retrieved with `response.params.id_token`.\n *\n * - [Get Started](https://docs.expo.dev/guides/authentication/#google)\n *\n * @param config\n * @param redirectUriOptions\n */\nexport function useIdTokenAuthRequest(\n  config: Partial<GoogleAuthRequestConfig>,\n  redirectUriOptions: Partial<AuthSessionRedirectUriOptions> = {}\n): [\n  GoogleAuthRequest | null,\n  AuthSessionResult | null,\n  (options?: AuthRequestPromptOptions) => Promise<AuthSessionResult>,\n] {\n  const isWebAuth = Platform.OS === 'web';\n\n  return useAuthRequest(\n    {\n      ...config,\n      responseType:\n        // If the client secret is provided then code can be used\n        !config.clientSecret &&\n        // When web auth is used, we can request the `id_token` directly without exchanging a code.\n        isWebAuth\n          ? ResponseType.IdToken\n          : undefined,\n    },\n    { ...redirectUriOptions }\n  );\n}\n\n/**\n * Load an authorization request.\n * Returns a loaded request, a response, and a prompt method.\n * When the prompt method completes, then the response will be fulfilled.\n *\n * - [Get Started](https://docs.expo.dev/guides/authentication/#google)\n *\n * @param config\n * @param redirectUriOptions\n */\nexport function useAuthRequest(\n  config: Partial<GoogleAuthRequestConfig> = {},\n  redirectUriOptions: Partial<AuthSessionRedirectUriOptions> = {}\n): [\n  GoogleAuthRequest | null,\n  AuthSessionResult | null,\n  (options?: AuthRequestPromptOptions) => Promise<AuthSessionResult>,\n] {\n  const clientId = useMemo((): string => {\n    const propertyName = Platform.select({\n      ios: 'iosClientId',\n      android: 'androidClientId',\n      default: 'webClientId',\n    });\n\n    const clientId = config[propertyName as any] ?? config.clientId;\n    invariantClientId(propertyName, clientId, 'Google');\n    return clientId;\n  }, [config.iosClientId, config.androidClientId, config.webClientId, config.clientId]);\n\n  const responseType = useMemo(() => {\n    // Allow overrides.\n    if (typeof config.responseType !== 'undefined') {\n      return config.responseType;\n    }\n    // You can only use `response_token=code` on installed apps (iOS, Android without proxy).\n    // Installed apps can auto exchange without a client secret and get the token and id-token (Firebase).\n    const isInstalledApp = Platform.OS !== 'web';\n    // If the user provided the client secret (they shouldn't!) then use code exchange by default.\n    if (config.clientSecret || isInstalledApp) {\n      return ResponseType.Code;\n    }\n    // This seems the most pragmatic option since it can result in a full authentication on web and proxy platforms as expected.\n    return ResponseType.Token;\n  }, [config.responseType, config.clientSecret]);\n\n  const redirectUri = useMemo((): string => {\n    if (typeof config.redirectUri !== 'undefined') {\n      return config.redirectUri;\n    }\n\n    return makeRedirectUri({\n      native: `${Application.applicationId}:/oauthredirect`,\n      ...redirectUriOptions,\n      // native: `com.googleusercontent.apps.${guid}:/oauthredirect`,\n    });\n  }, [config.redirectUri, redirectUriOptions]);\n\n  const extraParams = useMemo((): GoogleAuthRequestConfig['extraParams'] => {\n    const output = config.extraParams ? { ...config.extraParams } : {};\n\n    if (config.language) {\n      output.hl = output.language;\n    }\n    if (config.loginHint) {\n      output.login_hint = output.loginHint;\n    }\n    if (config.selectAccount) {\n      output.prompt = Prompt.SelectAccount;\n    }\n    return output;\n  }, [config.extraParams, config.language, config.loginHint, config.selectAccount]);\n\n  const request = useLoadedAuthRequest(\n    {\n      ...config,\n      responseType,\n      extraParams,\n      clientId,\n      redirectUri,\n    },\n    discovery,\n    GoogleAuthRequest\n  );\n\n  const [result, promptAsync] = useAuthRequestResult(request, discovery, {\n    windowFeatures: settings.windowFeatures,\n  });\n\n  const [fullResult, setFullResult] = useState<AuthSessionResult | null>(null);\n\n  const shouldAutoExchangeCode = useMemo(() => {\n    // allow overrides\n    if (typeof config.shouldAutoExchangeCode !== 'undefined') {\n      return config.shouldAutoExchangeCode;\n    }\n\n    // has a code to exchange and doesn't have an authentication yet.\n    return result?.type === 'success' && result.params.code && !result.authentication;\n  }, [config.shouldAutoExchangeCode, result?.type]);\n\n  useEffect(() => {\n    let isMounted = true;\n    if (shouldAutoExchangeCode && result?.type === 'success') {\n      const exchangeRequest = new AccessTokenRequest({\n        clientId,\n        clientSecret: config.clientSecret,\n        redirectUri,\n        scopes: config.scopes,\n        code: result.params.code,\n        extraParams: {\n          code_verifier: request?.codeVerifier || '',\n        },\n      });\n      exchangeRequest.performAsync(discovery).then((authentication) => {\n        if (isMounted) {\n          setFullResult({\n            ...result,\n            params: {\n              id_token: authentication?.idToken || '',\n              access_token: authentication.accessToken,\n              ...result.params,\n            },\n            authentication,\n          });\n        }\n      });\n    } else {\n      setFullResult(result);\n    }\n    return () => {\n      isMounted = false;\n    };\n  }, [\n    clientId,\n    redirectUri,\n    shouldAutoExchangeCode,\n    config.clientSecret,\n    config.scopes?.join(','),\n    request?.codeVerifier,\n    result,\n  ]);\n\n  return [request, fullResult, promptAsync];\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{"hasCjsExports":false},"sourceType":"module","externalDependencies":[]}