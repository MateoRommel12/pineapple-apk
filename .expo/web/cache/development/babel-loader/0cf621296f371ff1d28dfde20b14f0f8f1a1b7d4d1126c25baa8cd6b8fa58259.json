{"ast":null,"code":"import invariant from 'invariant';\nimport Platform from \"react-native-web/dist/exports/Platform\";\nimport * as Base64 from './Base64';\nimport { TokenError } from './Errors';\nimport { requestAsync } from './Fetch';\nimport { GrantType } from './TokenRequest.types';\nexport function getCurrentTimeInSeconds() {\n  return Math.floor(Date.now() / 1000);\n}\nexport class TokenResponse {\n  static isTokenFresh(token, secondsMargin = 60 * 10 * -1) {\n    if (!token) {\n      return false;\n    }\n    if (token.expiresIn) {\n      const now = getCurrentTimeInSeconds();\n      return now < token.issuedAt + token.expiresIn + secondsMargin;\n    }\n    return true;\n  }\n  static fromQueryParams(params) {\n    return new TokenResponse({\n      accessToken: params.access_token,\n      refreshToken: params.refresh_token,\n      scope: params.scope,\n      state: params.state,\n      idToken: params.id_token,\n      tokenType: params.token_type,\n      expiresIn: params.expires_in,\n      issuedAt: params.issued_at\n    });\n  }\n  constructor(response) {\n    this.accessToken = response.accessToken;\n    this.tokenType = response.tokenType ?? 'bearer';\n    this.expiresIn = response.expiresIn;\n    this.refreshToken = response.refreshToken;\n    this.scope = response.scope;\n    this.state = response.state;\n    this.idToken = response.idToken;\n    this.issuedAt = response.issuedAt ?? getCurrentTimeInSeconds();\n  }\n  applyResponseConfig(response) {\n    this.accessToken = response.accessToken ?? this.accessToken;\n    this.tokenType = response.tokenType ?? this.tokenType ?? 'bearer';\n    this.expiresIn = response.expiresIn ?? this.expiresIn;\n    this.refreshToken = response.refreshToken ?? this.refreshToken;\n    this.scope = response.scope ?? this.scope;\n    this.state = response.state ?? this.state;\n    this.idToken = response.idToken ?? this.idToken;\n    this.issuedAt = response.issuedAt ?? this.issuedAt ?? getCurrentTimeInSeconds();\n  }\n  getRequestConfig() {\n    return {\n      accessToken: this.accessToken,\n      idToken: this.idToken,\n      refreshToken: this.refreshToken,\n      scope: this.scope,\n      state: this.state,\n      tokenType: this.tokenType,\n      issuedAt: this.issuedAt,\n      expiresIn: this.expiresIn\n    };\n  }\n  async refreshAsync(config, discovery) {\n    const request = new RefreshTokenRequest(Object.assign({}, config, {\n      refreshToken: this.refreshToken\n    }));\n    const response = await request.performAsync(discovery);\n    response.refreshToken = response.refreshToken ?? this.refreshToken;\n    const json = response.getRequestConfig();\n    this.applyResponseConfig(json);\n    return this;\n  }\n  shouldRefresh() {\n    return !(TokenResponse.isTokenFresh(this) || !this.refreshToken);\n  }\n}\nexport class Request {\n  constructor(request) {\n    this.request = request;\n  }\n  async performAsync(discovery) {\n    throw new Error('performAsync must be extended');\n  }\n  getRequestConfig() {\n    throw new Error('getRequestConfig must be extended');\n  }\n  getQueryBody() {\n    throw new Error('getQueryBody must be extended');\n  }\n}\nexport class TokenRequest extends Request {\n  constructor(request, grantType) {\n    super(request);\n    this.grantType = grantType;\n    this.clientId = request.clientId;\n    this.clientSecret = request.clientSecret;\n    this.extraParams = request.extraParams;\n    this.scopes = request.scopes;\n  }\n  getHeaders() {\n    const headers = {\n      'Content-Type': 'application/x-www-form-urlencoded'\n    };\n    if (typeof this.clientSecret !== 'undefined') {\n      const encodedClientId = encodeURIComponent(this.clientId);\n      const encodedClientSecret = encodeURIComponent(this.clientSecret);\n      const credentials = `${encodedClientId}:${encodedClientSecret}`;\n      const basicAuth = Base64.encodeNoWrap(credentials);\n      headers.Authorization = `Basic ${basicAuth}`;\n    }\n    return headers;\n  }\n  async performAsync(discovery) {\n    invariant(discovery.tokenEndpoint, `Cannot invoke \\`performAsync()\\` without a valid tokenEndpoint`);\n    const response = await requestAsync(discovery.tokenEndpoint, {\n      dataType: 'json',\n      method: 'POST',\n      headers: this.getHeaders(),\n      body: this.getQueryBody()\n    });\n    if ('error' in response) {\n      throw new TokenError(response);\n    }\n    return new TokenResponse({\n      accessToken: response.access_token,\n      tokenType: response.token_type,\n      expiresIn: response.expires_in,\n      refreshToken: response.refresh_token,\n      scope: response.scope,\n      idToken: response.id_token,\n      issuedAt: response.issued_at\n    });\n  }\n  getQueryBody() {\n    const queryBody = {\n      grant_type: this.grantType\n    };\n    if (!this.clientSecret) {\n      queryBody.client_id = this.clientId;\n    }\n    if (this.scopes) {\n      queryBody.scope = this.scopes.join(' ');\n    }\n    if (this.extraParams) {\n      for (const extra in this.extraParams) {\n        if (extra in this.extraParams && !(extra in queryBody)) {\n          queryBody[extra] = this.extraParams[extra];\n        }\n      }\n    }\n    return queryBody;\n  }\n}\nexport class AccessTokenRequest extends TokenRequest {\n  constructor(options) {\n    invariant(options.redirectUri, `\\`AccessTokenRequest\\` requires a valid \\`redirectUri\\` (it must also match the one used in the auth request). Example: ${Platform.select({\n      web: 'https://yourwebsite.com/redirect',\n      default: 'myapp://redirect'\n    })}`);\n    invariant(options.code, `\\`AccessTokenRequest\\` requires a valid authorization \\`code\\`. This is what's received from the authorization server after an auth request.`);\n    super(options, GrantType.AuthorizationCode);\n    this.code = options.code;\n    this.redirectUri = options.redirectUri;\n  }\n  getQueryBody() {\n    const queryBody = super.getQueryBody();\n    if (this.redirectUri) {\n      queryBody.redirect_uri = this.redirectUri;\n    }\n    if (this.code) {\n      queryBody.code = this.code;\n    }\n    return queryBody;\n  }\n  getRequestConfig() {\n    return {\n      clientId: this.clientId,\n      clientSecret: this.clientSecret,\n      grantType: this.grantType,\n      code: this.code,\n      redirectUri: this.redirectUri,\n      extraParams: this.extraParams,\n      scopes: this.scopes\n    };\n  }\n}\nexport class RefreshTokenRequest extends TokenRequest {\n  constructor(options) {\n    invariant(options.refreshToken, `\\`RefreshTokenRequest\\` requires a valid \\`refreshToken\\`.`);\n    super(options, GrantType.RefreshToken);\n    this.refreshToken = options.refreshToken;\n  }\n  getQueryBody() {\n    const queryBody = super.getQueryBody();\n    if (this.refreshToken) {\n      queryBody.refresh_token = this.refreshToken;\n    }\n    return queryBody;\n  }\n  getRequestConfig() {\n    return {\n      clientId: this.clientId,\n      clientSecret: this.clientSecret,\n      grantType: this.grantType,\n      refreshToken: this.refreshToken,\n      extraParams: this.extraParams,\n      scopes: this.scopes\n    };\n  }\n}\nexport class RevokeTokenRequest extends Request {\n  constructor(request) {\n    super(request);\n    invariant(request.token, `\\`RevokeTokenRequest\\` requires a valid \\`token\\` to revoke.`);\n    this.clientId = request.clientId;\n    this.clientSecret = request.clientSecret;\n    this.token = request.token;\n    this.tokenTypeHint = request.tokenTypeHint;\n  }\n  getHeaders() {\n    const headers = {\n      'Content-Type': 'application/x-www-form-urlencoded'\n    };\n    if (typeof this.clientSecret !== 'undefined' && this.clientId) {\n      const encodedClientId = encodeURIComponent(this.clientId);\n      const encodedClientSecret = encodeURIComponent(this.clientSecret);\n      const credentials = `${encodedClientId}:${encodedClientSecret}`;\n      const basicAuth = Base64.encodeNoWrap(credentials);\n      headers.Authorization = `Basic ${basicAuth}`;\n    }\n    return headers;\n  }\n  async performAsync(discovery) {\n    invariant(discovery.revocationEndpoint, `Cannot invoke \\`performAsync()\\` without a valid revocationEndpoint`);\n    await requestAsync(discovery.revocationEndpoint, {\n      method: 'POST',\n      headers: this.getHeaders(),\n      body: this.getQueryBody()\n    });\n    return true;\n  }\n  getRequestConfig() {\n    return {\n      clientId: this.clientId,\n      clientSecret: this.clientSecret,\n      token: this.token,\n      tokenTypeHint: this.tokenTypeHint\n    };\n  }\n  getQueryBody() {\n    const queryBody = {\n      token: this.token\n    };\n    if (this.tokenTypeHint) {\n      queryBody.token_type_hint = this.tokenTypeHint;\n    }\n    if (this.clientId) {\n      queryBody.client_id = this.clientId;\n    }\n    if (this.clientSecret) {\n      queryBody.client_secret = this.clientSecret;\n    }\n    return queryBody;\n  }\n}\nexport function exchangeCodeAsync(config, discovery) {\n  const request = new AccessTokenRequest(config);\n  return request.performAsync(discovery);\n}\nexport function refreshAsync(config, discovery) {\n  const request = new RefreshTokenRequest(config);\n  return request.performAsync(discovery);\n}\nexport function revokeAsync(config, discovery) {\n  const request = new RevokeTokenRequest(config);\n  return request.performAsync(discovery);\n}\nexport function fetchUserInfoAsync(config, discovery) {\n  if (!discovery.userInfoEndpoint) {\n    throw new Error('User info endpoint is not defined in the service config discovery document');\n  }\n  return requestAsync(discovery.userInfoEndpoint, {\n    headers: {\n      'Content-Type': 'application/x-www-form-urlencoded',\n      Authorization: `Bearer ${config.accessToken}`\n    },\n    dataType: 'json',\n    method: 'GET'\n  });\n}","map":{"version":3,"names":["invariant","Platform","Base64","TokenError","requestAsync","GrantType","getCurrentTimeInSeconds","Math","floor","Date","now","TokenResponse","isTokenFresh","token","secondsMargin","expiresIn","issuedAt","fromQueryParams","params","accessToken","access_token","refreshToken","refresh_token","scope","state","idToken","id_token","tokenType","token_type","expires_in","issued_at","constructor","response","applyResponseConfig","getRequestConfig","refreshAsync","config","discovery","request","RefreshTokenRequest","Object","assign","performAsync","json","shouldRefresh","Request","Error","getQueryBody","TokenRequest","grantType","clientId","clientSecret","extraParams","scopes","getHeaders","headers","encodedClientId","encodeURIComponent","encodedClientSecret","credentials","basicAuth","encodeNoWrap","Authorization","tokenEndpoint","dataType","method","body","queryBody","grant_type","client_id","join","extra","AccessTokenRequest","options","redirectUri","select","web","default","code","AuthorizationCode","redirect_uri","RefreshToken","RevokeTokenRequest","tokenTypeHint","revocationEndpoint","token_type_hint","client_secret","exchangeCodeAsync","revokeAsync","fetchUserInfoAsync","userInfoEndpoint"],"sources":["C:\\Users\\ACER\\Documents\\Capstone\\node_modules\\expo-auth-session\\src\\TokenRequest.ts"],"sourcesContent":["import invariant from 'invariant';\nimport { Platform } from 'react-native';\n\nimport * as Base64 from './Base64';\nimport * as ServiceConfig from './Discovery';\nimport { ResponseErrorConfig, TokenError } from './Errors';\nimport { Headers, requestAsync } from './Fetch';\nimport {\n  AccessTokenRequestConfig,\n  GrantType,\n  RefreshTokenRequestConfig,\n  RevokeTokenRequestConfig,\n  ServerTokenResponseConfig,\n  TokenRequestConfig,\n  TokenResponseConfig,\n  TokenType,\n  TokenTypeHint,\n} from './TokenRequest.types';\n\n/**\n * Returns the current time in seconds.\n */\nexport function getCurrentTimeInSeconds(): number {\n  return Math.floor(Date.now() / 1000);\n}\n\n/**\n * Token Response.\n *\n * [Section 5.1](https://tools.ietf.org/html/rfc6749#section-5.1)\n */\nexport class TokenResponse implements TokenResponseConfig {\n  /**\n   * Determines whether a token refresh request must be made to refresh the tokens\n   *\n   * @param token\n   * @param secondsMargin\n   */\n  static isTokenFresh(\n    token: Pick<TokenResponse, 'expiresIn' | 'issuedAt'>,\n    /**\n     * -10 minutes in seconds\n     */\n    secondsMargin: number = 60 * 10 * -1\n  ): boolean {\n    if (!token) {\n      return false;\n    }\n    if (token.expiresIn) {\n      const now = getCurrentTimeInSeconds();\n      return now < token.issuedAt + token.expiresIn + secondsMargin;\n    }\n    // if there is no expiration time but we have an access token, it is assumed to never expire\n    return true;\n  }\n  /**\n   * Creates a `TokenResponse` from query parameters returned from an `AuthRequest`.\n   *\n   * @param params\n   */\n  static fromQueryParams(params: Record<string, any>): TokenResponse {\n    return new TokenResponse({\n      accessToken: params.access_token,\n      refreshToken: params.refresh_token,\n      scope: params.scope,\n      state: params.state,\n      idToken: params.id_token,\n      tokenType: params.token_type,\n      expiresIn: params.expires_in,\n      issuedAt: params.issued_at,\n    });\n  }\n\n  accessToken: string;\n  tokenType: TokenType;\n  expiresIn?: number;\n  refreshToken?: string;\n  scope?: string;\n  state?: string;\n  idToken?: string;\n  issuedAt: number;\n\n  constructor(response: TokenResponseConfig) {\n    this.accessToken = response.accessToken;\n    this.tokenType = response.tokenType ?? 'bearer';\n    this.expiresIn = response.expiresIn;\n    this.refreshToken = response.refreshToken;\n    this.scope = response.scope;\n    this.state = response.state;\n    this.idToken = response.idToken;\n    this.issuedAt = response.issuedAt ?? getCurrentTimeInSeconds();\n  }\n\n  private applyResponseConfig(response: TokenResponseConfig) {\n    this.accessToken = response.accessToken ?? this.accessToken;\n    this.tokenType = response.tokenType ?? this.tokenType ?? 'bearer';\n    this.expiresIn = response.expiresIn ?? this.expiresIn;\n    this.refreshToken = response.refreshToken ?? this.refreshToken;\n    this.scope = response.scope ?? this.scope;\n    this.state = response.state ?? this.state;\n    this.idToken = response.idToken ?? this.idToken;\n    this.issuedAt = response.issuedAt ?? this.issuedAt ?? getCurrentTimeInSeconds();\n  }\n\n  getRequestConfig(): TokenResponseConfig {\n    return {\n      accessToken: this.accessToken,\n      idToken: this.idToken,\n      refreshToken: this.refreshToken,\n      scope: this.scope,\n      state: this.state,\n      tokenType: this.tokenType,\n      issuedAt: this.issuedAt,\n      expiresIn: this.expiresIn,\n    };\n  }\n\n  async refreshAsync(\n    config: Omit<TokenRequestConfig, 'grantType' | 'refreshToken'>,\n    discovery: Pick<ServiceConfig.DiscoveryDocument, 'tokenEndpoint'>\n  ): Promise<TokenResponse> {\n    const request = new RefreshTokenRequest({\n      ...config,\n      refreshToken: this.refreshToken,\n    });\n    const response = await request.performAsync(discovery);\n    // Custom: reuse the refresh token if one wasn't returned\n    response.refreshToken = response.refreshToken ?? this.refreshToken;\n    const json = response.getRequestConfig();\n    this.applyResponseConfig(json);\n    return this;\n  }\n\n  shouldRefresh(): boolean {\n    // no refresh token available and token has expired\n    return !(TokenResponse.isTokenFresh(this) || !this.refreshToken);\n  }\n}\n\nexport class Request<T, B> {\n  constructor(protected request: T) {}\n\n  async performAsync(discovery: ServiceConfig.DiscoveryDocument): Promise<B> {\n    throw new Error('performAsync must be extended');\n  }\n\n  getRequestConfig(): T {\n    throw new Error('getRequestConfig must be extended');\n  }\n\n  getQueryBody(): Record<string, string> {\n    throw new Error('getQueryBody must be extended');\n  }\n}\n\n/**\n * A generic token request.\n */\nexport class TokenRequest<T extends TokenRequestConfig> extends Request<T, TokenResponse> {\n  readonly clientId: string;\n  readonly clientSecret?: string;\n  readonly scopes?: string[];\n  readonly extraParams?: Record<string, string>;\n\n  constructor(\n    request,\n    public grantType: GrantType\n  ) {\n    super(request);\n    this.clientId = request.clientId;\n    this.clientSecret = request.clientSecret;\n    this.extraParams = request.extraParams;\n    this.scopes = request.scopes;\n  }\n\n  getHeaders(): Headers {\n    const headers: Headers = { 'Content-Type': 'application/x-www-form-urlencoded' };\n    if (typeof this.clientSecret !== 'undefined') {\n      // If client secret exists, it should be converted to base64\n      // https://tools.ietf.org/html/rfc6749#section-2.3.1\n      const encodedClientId = encodeURIComponent(this.clientId);\n      const encodedClientSecret = encodeURIComponent(this.clientSecret);\n      const credentials = `${encodedClientId}:${encodedClientSecret}`;\n      const basicAuth = Base64.encodeNoWrap(credentials);\n      headers.Authorization = `Basic ${basicAuth}`;\n    }\n\n    return headers;\n  }\n\n  async performAsync(discovery: Pick<ServiceConfig.DiscoveryDocument, 'tokenEndpoint'>) {\n    // redirect URI must not be nil\n    invariant(\n      discovery.tokenEndpoint,\n      `Cannot invoke \\`performAsync()\\` without a valid tokenEndpoint`\n    );\n    const response = await requestAsync<ServerTokenResponseConfig | ResponseErrorConfig>(\n      discovery.tokenEndpoint,\n      {\n        dataType: 'json',\n        method: 'POST',\n        headers: this.getHeaders(),\n        body: this.getQueryBody(),\n      }\n    );\n\n    if ('error' in response) {\n      throw new TokenError(response);\n    }\n\n    return new TokenResponse({\n      accessToken: response.access_token,\n      tokenType: response.token_type,\n      expiresIn: response.expires_in,\n      refreshToken: response.refresh_token,\n      scope: response.scope,\n      idToken: response.id_token,\n      issuedAt: response.issued_at,\n    });\n  }\n\n  getQueryBody() {\n    const queryBody: Record<string, string> = {\n      grant_type: this.grantType,\n    };\n\n    if (!this.clientSecret) {\n      // Only add the client ID if client secret is not present, otherwise pass the client id with the secret in the request body.\n      queryBody.client_id = this.clientId;\n    }\n\n    if (this.scopes) {\n      queryBody.scope = this.scopes.join(' ');\n    }\n\n    if (this.extraParams) {\n      for (const extra in this.extraParams) {\n        if (extra in this.extraParams && !(extra in queryBody)) {\n          queryBody[extra] = this.extraParams[extra];\n        }\n      }\n    }\n    return queryBody;\n  }\n}\n\n/**\n * Access token request. Exchange an authorization code for a user access token.\n *\n * [Section 4.1.3](https://tools.ietf.org/html/rfc6749#section-4.1.3)\n */\nexport class AccessTokenRequest\n  extends TokenRequest<AccessTokenRequestConfig>\n  implements AccessTokenRequestConfig\n{\n  readonly code: string;\n  readonly redirectUri: string;\n\n  constructor(options: AccessTokenRequestConfig) {\n    invariant(\n      options.redirectUri,\n      `\\`AccessTokenRequest\\` requires a valid \\`redirectUri\\` (it must also match the one used in the auth request). Example: ${Platform.select(\n        {\n          web: 'https://yourwebsite.com/redirect',\n          default: 'myapp://redirect',\n        }\n      )}`\n    );\n\n    invariant(\n      options.code,\n      `\\`AccessTokenRequest\\` requires a valid authorization \\`code\\`. This is what's received from the authorization server after an auth request.`\n    );\n    super(options, GrantType.AuthorizationCode);\n    this.code = options.code;\n    this.redirectUri = options.redirectUri;\n  }\n\n  getQueryBody() {\n    const queryBody: Record<string, string> = super.getQueryBody();\n\n    if (this.redirectUri) {\n      queryBody.redirect_uri = this.redirectUri;\n    }\n\n    if (this.code) {\n      queryBody.code = this.code;\n    }\n\n    return queryBody;\n  }\n\n  getRequestConfig() {\n    return {\n      clientId: this.clientId,\n      clientSecret: this.clientSecret,\n      grantType: this.grantType,\n      code: this.code,\n      redirectUri: this.redirectUri,\n      extraParams: this.extraParams,\n      scopes: this.scopes,\n    };\n  }\n}\n\n/**\n * Refresh request.\n *\n * [Section 6](https://tools.ietf.org/html/rfc6749#section-6)\n */\nexport class RefreshTokenRequest\n  extends TokenRequest<RefreshTokenRequestConfig>\n  implements RefreshTokenRequestConfig\n{\n  readonly refreshToken?: string;\n\n  constructor(options: RefreshTokenRequestConfig) {\n    invariant(options.refreshToken, `\\`RefreshTokenRequest\\` requires a valid \\`refreshToken\\`.`);\n    super(options, GrantType.RefreshToken);\n    this.refreshToken = options.refreshToken;\n  }\n\n  getQueryBody() {\n    const queryBody = super.getQueryBody();\n\n    if (this.refreshToken) {\n      queryBody.refresh_token = this.refreshToken;\n    }\n\n    return queryBody;\n  }\n\n  getRequestConfig() {\n    return {\n      clientId: this.clientId,\n      clientSecret: this.clientSecret,\n      grantType: this.grantType,\n      refreshToken: this.refreshToken,\n      extraParams: this.extraParams,\n      scopes: this.scopes,\n    };\n  }\n}\n\n/**\n * Revocation request for a given token.\n *\n * [Section 2.1](https://tools.ietf.org/html/rfc7009#section-2.1)\n */\nexport class RevokeTokenRequest\n  extends Request<RevokeTokenRequestConfig, boolean>\n  implements RevokeTokenRequestConfig\n{\n  readonly clientId?: string;\n  readonly clientSecret?: string;\n  readonly token: string;\n  readonly tokenTypeHint?: TokenTypeHint;\n\n  constructor(request: RevokeTokenRequestConfig) {\n    super(request);\n    invariant(request.token, `\\`RevokeTokenRequest\\` requires a valid \\`token\\` to revoke.`);\n    this.clientId = request.clientId;\n    this.clientSecret = request.clientSecret;\n    this.token = request.token;\n    this.tokenTypeHint = request.tokenTypeHint;\n  }\n\n  getHeaders(): Headers {\n    const headers: Headers = { 'Content-Type': 'application/x-www-form-urlencoded' };\n    if (typeof this.clientSecret !== 'undefined' && this.clientId) {\n      // If client secret exists, it should be converted to base64\n      // https://tools.ietf.org/html/rfc6749#section-2.3.1\n      const encodedClientId = encodeURIComponent(this.clientId);\n      const encodedClientSecret = encodeURIComponent(this.clientSecret);\n      const credentials = `${encodedClientId}:${encodedClientSecret}`;\n      const basicAuth = Base64.encodeNoWrap(credentials);\n      headers.Authorization = `Basic ${basicAuth}`;\n    }\n\n    return headers;\n  }\n\n  /**\n   * Perform a token revocation request.\n   *\n   * @param discovery The `revocationEndpoint` for a provider.\n   */\n  async performAsync(discovery: Pick<ServiceConfig.DiscoveryDocument, 'revocationEndpoint'>) {\n    invariant(\n      discovery.revocationEndpoint,\n      `Cannot invoke \\`performAsync()\\` without a valid revocationEndpoint`\n    );\n    await requestAsync<boolean>(discovery.revocationEndpoint, {\n      method: 'POST',\n      headers: this.getHeaders(),\n      body: this.getQueryBody(),\n    });\n\n    return true;\n  }\n\n  getRequestConfig() {\n    return {\n      clientId: this.clientId,\n      clientSecret: this.clientSecret,\n      token: this.token,\n      tokenTypeHint: this.tokenTypeHint,\n    };\n  }\n\n  getQueryBody(): Record<string, string> {\n    const queryBody: Record<string, string> = { token: this.token };\n    if (this.tokenTypeHint) {\n      queryBody.token_type_hint = this.tokenTypeHint;\n    }\n    // Include client creds https://tools.ietf.org/html/rfc6749#section-2.3.1\n    if (this.clientId) {\n      queryBody.client_id = this.clientId;\n    }\n    if (this.clientSecret) {\n      queryBody.client_secret = this.clientSecret;\n    }\n    return queryBody;\n  }\n}\n\n// @needsAudit\n/**\n * Exchange an authorization code for an access token that can be used to get data from the provider.\n *\n * @param config Configuration used to exchange the code for a token.\n * @param discovery The `tokenEndpoint` for a provider.\n * @return Returns a discovery document with a valid `tokenEndpoint` URL.\n */\nexport function exchangeCodeAsync(\n  config: AccessTokenRequestConfig,\n  discovery: Pick<ServiceConfig.DiscoveryDocument, 'tokenEndpoint'>\n): Promise<TokenResponse> {\n  const request = new AccessTokenRequest(config);\n  return request.performAsync(discovery);\n}\n\n// @needsAudit\n/**\n * Refresh an access token.\n * - If the provider didn't return a `refresh_token` then the access token may not be refreshed.\n * - If the provider didn't return a `expires_in` then it's assumed that the token does not expire.\n * - Determine if a token needs to be refreshed via `TokenResponse.isTokenFresh()` or `shouldRefresh()` on an instance of `TokenResponse`.\n *\n * @see [Section 6](https://tools.ietf.org/html/rfc6749#section-6).\n *\n * @param config Configuration used to refresh the given access token.\n * @param discovery The `tokenEndpoint` for a provider.\n * @return Returns a discovery document with a valid `tokenEndpoint` URL.\n */\nexport function refreshAsync(\n  config: RefreshTokenRequestConfig,\n  discovery: Pick<ServiceConfig.DiscoveryDocument, 'tokenEndpoint'>\n): Promise<TokenResponse> {\n  const request = new RefreshTokenRequest(config);\n  return request.performAsync(discovery);\n}\n\n// @needsAudit\n/**\n * Revoke a token with a provider. This makes the token unusable, effectively requiring the user to login again.\n *\n * @param config Configuration used to revoke a refresh or access token.\n * @param discovery The `revocationEndpoint` for a provider.\n * @return Returns a discovery document with a valid `revocationEndpoint` URL. Many providers do not support this feature.\n */\nexport function revokeAsync(\n  config: RevokeTokenRequestConfig,\n  discovery: Pick<ServiceConfig.DiscoveryDocument, 'revocationEndpoint'>\n): Promise<boolean> {\n  const request = new RevokeTokenRequest(config);\n  return request.performAsync(discovery);\n}\n\n/**\n * Fetch generic user info from the provider's OpenID Connect `userInfoEndpoint` (if supported).\n *\n * @see [UserInfo](https://openid.net/specs/openid-connect-core-1_0.html#UserInfo).\n *\n * @param config The `accessToken` for a user, returned from a code exchange or auth request.\n * @param discovery The `userInfoEndpoint` for a provider.\n */\nexport function fetchUserInfoAsync(\n  config: Pick<TokenResponse, 'accessToken'>,\n  discovery: Pick<ServiceConfig.DiscoveryDocument, 'userInfoEndpoint'>\n): Promise<Record<string, any>> {\n  if (!discovery.userInfoEndpoint) {\n    throw new Error('User info endpoint is not defined in the service config discovery document');\n  }\n  return requestAsync<Record<string, any>>(discovery.userInfoEndpoint, {\n    headers: {\n      'Content-Type': 'application/x-www-form-urlencoded',\n      Authorization: `Bearer ${config.accessToken}`,\n    },\n    dataType: 'json',\n    method: 'GET',\n  });\n}\n"],"mappings":"AAAA,OAAOA,SAAS,MAAM,WAAW;AAAC,OAAAC,QAAA;AAGlC,OAAO,KAAKC,MAAM,MAAM,UAAU;AAElC,SAA8BC,UAAU,QAAQ,UAAU;AAC1D,SAAkBC,YAAY,QAAQ,SAAS;AAC/C,SAEEC,SAAS,QAQJ,sBAAsB;AAK7B,OAAM,SAAUC,uBAAuBA,CAAA;EACrC,OAAOC,IAAI,CAACC,KAAK,CAACC,IAAI,CAACC,GAAG,EAAE,GAAG,IAAI,CAAC;AACtC;AAOA,OAAM,MAAOC,aAAa;EAOxB,OAAOC,YAAYA,CACjBC,KAAoD,EAIpDC,aAAA,GAAwB,EAAE,GAAG,EAAE,GAAG,CAAC,CAAC;IAEpC,IAAI,CAACD,KAAK,EAAE;MACV,OAAO,KAAK;;IAEd,IAAIA,KAAK,CAACE,SAAS,EAAE;MACnB,MAAML,GAAG,GAAGJ,uBAAuB,EAAE;MACrC,OAAOI,GAAG,GAAGG,KAAK,CAACG,QAAQ,GAAGH,KAAK,CAACE,SAAS,GAAGD,aAAa;;IAG/D,OAAO,IAAI;EACb;EAMA,OAAOG,eAAeA,CAACC,MAA2B;IAChD,OAAO,IAAIP,aAAa,CAAC;MACvBQ,WAAW,EAAED,MAAM,CAACE,YAAY;MAChCC,YAAY,EAAEH,MAAM,CAACI,aAAa;MAClCC,KAAK,EAAEL,MAAM,CAACK,KAAK;MACnBC,KAAK,EAAEN,MAAM,CAACM,KAAK;MACnBC,OAAO,EAAEP,MAAM,CAACQ,QAAQ;MACxBC,SAAS,EAAET,MAAM,CAACU,UAAU;MAC5Bb,SAAS,EAAEG,MAAM,CAACW,UAAU;MAC5Bb,QAAQ,EAAEE,MAAM,CAACY;KAClB,CAAC;EACJ;EAWAC,YAAYC,QAA6B;IACvC,IAAI,CAACb,WAAW,GAAGa,QAAQ,CAACb,WAAW;IACvC,IAAI,CAACQ,SAAS,GAAGK,QAAQ,CAACL,SAAS,IAAI,QAAQ;IAC/C,IAAI,CAACZ,SAAS,GAAGiB,QAAQ,CAACjB,SAAS;IACnC,IAAI,CAACM,YAAY,GAAGW,QAAQ,CAACX,YAAY;IACzC,IAAI,CAACE,KAAK,GAAGS,QAAQ,CAACT,KAAK;IAC3B,IAAI,CAACC,KAAK,GAAGQ,QAAQ,CAACR,KAAK;IAC3B,IAAI,CAACC,OAAO,GAAGO,QAAQ,CAACP,OAAO;IAC/B,IAAI,CAACT,QAAQ,GAAGgB,QAAQ,CAAChB,QAAQ,IAAIV,uBAAuB,EAAE;EAChE;EAEQ2B,mBAAmBA,CAACD,QAA6B;IACvD,IAAI,CAACb,WAAW,GAAGa,QAAQ,CAACb,WAAW,IAAI,IAAI,CAACA,WAAW;IAC3D,IAAI,CAACQ,SAAS,GAAGK,QAAQ,CAACL,SAAS,IAAI,IAAI,CAACA,SAAS,IAAI,QAAQ;IACjE,IAAI,CAACZ,SAAS,GAAGiB,QAAQ,CAACjB,SAAS,IAAI,IAAI,CAACA,SAAS;IACrD,IAAI,CAACM,YAAY,GAAGW,QAAQ,CAACX,YAAY,IAAI,IAAI,CAACA,YAAY;IAC9D,IAAI,CAACE,KAAK,GAAGS,QAAQ,CAACT,KAAK,IAAI,IAAI,CAACA,KAAK;IACzC,IAAI,CAACC,KAAK,GAAGQ,QAAQ,CAACR,KAAK,IAAI,IAAI,CAACA,KAAK;IACzC,IAAI,CAACC,OAAO,GAAGO,QAAQ,CAACP,OAAO,IAAI,IAAI,CAACA,OAAO;IAC/C,IAAI,CAACT,QAAQ,GAAGgB,QAAQ,CAAChB,QAAQ,IAAI,IAAI,CAACA,QAAQ,IAAIV,uBAAuB,EAAE;EACjF;EAEA4B,gBAAgBA,CAAA;IACd,OAAO;MACLf,WAAW,EAAE,IAAI,CAACA,WAAW;MAC7BM,OAAO,EAAE,IAAI,CAACA,OAAO;MACrBJ,YAAY,EAAE,IAAI,CAACA,YAAY;MAC/BE,KAAK,EAAE,IAAI,CAACA,KAAK;MACjBC,KAAK,EAAE,IAAI,CAACA,KAAK;MACjBG,SAAS,EAAE,IAAI,CAACA,SAAS;MACzBX,QAAQ,EAAE,IAAI,CAACA,QAAQ;MACvBD,SAAS,EAAE,IAAI,CAACA;KACjB;EACH;EAEA,MAAMoB,YAAYA,CAChBC,MAA8D,EAC9DC,SAAiE;IAEjE,MAAMC,OAAO,GAAG,IAAIC,mBAAmB,CAAAC,MAAA,CAAAC,MAAA,KAClCL,MAAM;MACTf,YAAY,EAAE,IAAI,CAACA;IAAY,EAChC,CAAC;IACF,MAAMW,QAAQ,GAAG,MAAMM,OAAO,CAACI,YAAY,CAACL,SAAS,CAAC;IAEtDL,QAAQ,CAACX,YAAY,GAAGW,QAAQ,CAACX,YAAY,IAAI,IAAI,CAACA,YAAY;IAClE,MAAMsB,IAAI,GAAGX,QAAQ,CAACE,gBAAgB,EAAE;IACxC,IAAI,CAACD,mBAAmB,CAACU,IAAI,CAAC;IAC9B,OAAO,IAAI;EACb;EAEAC,aAAaA,CAAA;IAEX,OAAO,EAAEjC,aAAa,CAACC,YAAY,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,CAACS,YAAY,CAAC;EAClE;;AAGF,OAAM,MAAOwB,OAAO;EAClBd,YAAsBO,OAAU;IAAV,KAAAA,OAAO,GAAPA,OAAO;EAAM;EAEnC,MAAMI,YAAYA,CAACL,SAA0C;IAC3D,MAAM,IAAIS,KAAK,CAAC,+BAA+B,CAAC;EAClD;EAEAZ,gBAAgBA,CAAA;IACd,MAAM,IAAIY,KAAK,CAAC,mCAAmC,CAAC;EACtD;EAEAC,YAAYA,CAAA;IACV,MAAM,IAAID,KAAK,CAAC,+BAA+B,CAAC;EAClD;;AAMF,OAAM,MAAOE,YAA2C,SAAQH,OAAyB;EAMvFd,YACEO,OAAO,EACAW,SAAoB;IAE3B,KAAK,CAACX,OAAO,CAAC;IAFP,KAAAW,SAAS,GAATA,SAAS;IAGhB,IAAI,CAACC,QAAQ,GAAGZ,OAAO,CAACY,QAAQ;IAChC,IAAI,CAACC,YAAY,GAAGb,OAAO,CAACa,YAAY;IACxC,IAAI,CAACC,WAAW,GAAGd,OAAO,CAACc,WAAW;IACtC,IAAI,CAACC,MAAM,GAAGf,OAAO,CAACe,MAAM;EAC9B;EAEAC,UAAUA,CAAA;IACR,MAAMC,OAAO,GAAY;MAAE,cAAc,EAAE;IAAmC,CAAE;IAChF,IAAI,OAAO,IAAI,CAACJ,YAAY,KAAK,WAAW,EAAE;MAG5C,MAAMK,eAAe,GAAGC,kBAAkB,CAAC,IAAI,CAACP,QAAQ,CAAC;MACzD,MAAMQ,mBAAmB,GAAGD,kBAAkB,CAAC,IAAI,CAACN,YAAY,CAAC;MACjE,MAAMQ,WAAW,GAAG,GAAGH,eAAe,IAAIE,mBAAmB,EAAE;MAC/D,MAAME,SAAS,GAAG1D,MAAM,CAAC2D,YAAY,CAACF,WAAW,CAAC;MAClDJ,OAAO,CAACO,aAAa,GAAG,SAASF,SAAS,EAAE;;IAG9C,OAAOL,OAAO;EAChB;EAEA,MAAMb,YAAYA,CAACL,SAAiE;IAElFrC,SAAS,CACPqC,SAAS,CAAC0B,aAAa,EACvB,gEAAgE,CACjE;IACD,MAAM/B,QAAQ,GAAG,MAAM5B,YAAY,CACjCiC,SAAS,CAAC0B,aAAa,EACvB;MACEC,QAAQ,EAAE,MAAM;MAChBC,MAAM,EAAE,MAAM;MACdV,OAAO,EAAE,IAAI,CAACD,UAAU,EAAE;MAC1BY,IAAI,EAAE,IAAI,CAACnB,YAAY;KACxB,CACF;IAED,IAAI,OAAO,IAAIf,QAAQ,EAAE;MACvB,MAAM,IAAI7B,UAAU,CAAC6B,QAAQ,CAAC;;IAGhC,OAAO,IAAIrB,aAAa,CAAC;MACvBQ,WAAW,EAAEa,QAAQ,CAACZ,YAAY;MAClCO,SAAS,EAAEK,QAAQ,CAACJ,UAAU;MAC9Bb,SAAS,EAAEiB,QAAQ,CAACH,UAAU;MAC9BR,YAAY,EAAEW,QAAQ,CAACV,aAAa;MACpCC,KAAK,EAAES,QAAQ,CAACT,KAAK;MACrBE,OAAO,EAAEO,QAAQ,CAACN,QAAQ;MAC1BV,QAAQ,EAAEgB,QAAQ,CAACF;KACpB,CAAC;EACJ;EAEAiB,YAAYA,CAAA;IACV,MAAMoB,SAAS,GAA2B;MACxCC,UAAU,EAAE,IAAI,CAACnB;KAClB;IAED,IAAI,CAAC,IAAI,CAACE,YAAY,EAAE;MAEtBgB,SAAS,CAACE,SAAS,GAAG,IAAI,CAACnB,QAAQ;;IAGrC,IAAI,IAAI,CAACG,MAAM,EAAE;MACfc,SAAS,CAAC5C,KAAK,GAAG,IAAI,CAAC8B,MAAM,CAACiB,IAAI,CAAC,GAAG,CAAC;;IAGzC,IAAI,IAAI,CAAClB,WAAW,EAAE;MACpB,KAAK,MAAMmB,KAAK,IAAI,IAAI,CAACnB,WAAW,EAAE;QACpC,IAAImB,KAAK,IAAI,IAAI,CAACnB,WAAW,IAAI,EAAEmB,KAAK,IAAIJ,SAAS,CAAC,EAAE;UACtDA,SAAS,CAACI,KAAK,CAAC,GAAG,IAAI,CAACnB,WAAW,CAACmB,KAAK,CAAC;;;;IAIhD,OAAOJ,SAAS;EAClB;;AAQF,OAAM,MAAOK,kBACX,SAAQxB,YAAsC;EAM9CjB,YAAY0C,OAAiC;IAC3CzE,SAAS,CACPyE,OAAO,CAACC,WAAW,EACnB,2HAA2HzE,QAAQ,CAAC0E,MAAM,CACxI;MACEC,GAAG,EAAE,kCAAkC;MACvCC,OAAO,EAAE;KACV,CACF,EAAE,CACJ;IAED7E,SAAS,CACPyE,OAAO,CAACK,IAAI,EACZ,8IAA8I,CAC/I;IACD,KAAK,CAACL,OAAO,EAAEpE,SAAS,CAAC0E,iBAAiB,CAAC;IAC3C,IAAI,CAACD,IAAI,GAAGL,OAAO,CAACK,IAAI;IACxB,IAAI,CAACJ,WAAW,GAAGD,OAAO,CAACC,WAAW;EACxC;EAEA3B,YAAYA,CAAA;IACV,MAAMoB,SAAS,GAA2B,KAAK,CAACpB,YAAY,EAAE;IAE9D,IAAI,IAAI,CAAC2B,WAAW,EAAE;MACpBP,SAAS,CAACa,YAAY,GAAG,IAAI,CAACN,WAAW;;IAG3C,IAAI,IAAI,CAACI,IAAI,EAAE;MACbX,SAAS,CAACW,IAAI,GAAG,IAAI,CAACA,IAAI;;IAG5B,OAAOX,SAAS;EAClB;EAEAjC,gBAAgBA,CAAA;IACd,OAAO;MACLgB,QAAQ,EAAE,IAAI,CAACA,QAAQ;MACvBC,YAAY,EAAE,IAAI,CAACA,YAAY;MAC/BF,SAAS,EAAE,IAAI,CAACA,SAAS;MACzB6B,IAAI,EAAE,IAAI,CAACA,IAAI;MACfJ,WAAW,EAAE,IAAI,CAACA,WAAW;MAC7BtB,WAAW,EAAE,IAAI,CAACA,WAAW;MAC7BC,MAAM,EAAE,IAAI,CAACA;KACd;EACH;;AAQF,OAAM,MAAOd,mBACX,SAAQS,YAAuC;EAK/CjB,YAAY0C,OAAkC;IAC5CzE,SAAS,CAACyE,OAAO,CAACpD,YAAY,EAAE,4DAA4D,CAAC;IAC7F,KAAK,CAACoD,OAAO,EAAEpE,SAAS,CAAC4E,YAAY,CAAC;IACtC,IAAI,CAAC5D,YAAY,GAAGoD,OAAO,CAACpD,YAAY;EAC1C;EAEA0B,YAAYA,CAAA;IACV,MAAMoB,SAAS,GAAG,KAAK,CAACpB,YAAY,EAAE;IAEtC,IAAI,IAAI,CAAC1B,YAAY,EAAE;MACrB8C,SAAS,CAAC7C,aAAa,GAAG,IAAI,CAACD,YAAY;;IAG7C,OAAO8C,SAAS;EAClB;EAEAjC,gBAAgBA,CAAA;IACd,OAAO;MACLgB,QAAQ,EAAE,IAAI,CAACA,QAAQ;MACvBC,YAAY,EAAE,IAAI,CAACA,YAAY;MAC/BF,SAAS,EAAE,IAAI,CAACA,SAAS;MACzB5B,YAAY,EAAE,IAAI,CAACA,YAAY;MAC/B+B,WAAW,EAAE,IAAI,CAACA,WAAW;MAC7BC,MAAM,EAAE,IAAI,CAACA;KACd;EACH;;AAQF,OAAM,MAAO6B,kBACX,SAAQrC,OAA0C;EAQlDd,YAAYO,OAAiC;IAC3C,KAAK,CAACA,OAAO,CAAC;IACdtC,SAAS,CAACsC,OAAO,CAACzB,KAAK,EAAE,8DAA8D,CAAC;IACxF,IAAI,CAACqC,QAAQ,GAAGZ,OAAO,CAACY,QAAQ;IAChC,IAAI,CAACC,YAAY,GAAGb,OAAO,CAACa,YAAY;IACxC,IAAI,CAACtC,KAAK,GAAGyB,OAAO,CAACzB,KAAK;IAC1B,IAAI,CAACsE,aAAa,GAAG7C,OAAO,CAAC6C,aAAa;EAC5C;EAEA7B,UAAUA,CAAA;IACR,MAAMC,OAAO,GAAY;MAAE,cAAc,EAAE;IAAmC,CAAE;IAChF,IAAI,OAAO,IAAI,CAACJ,YAAY,KAAK,WAAW,IAAI,IAAI,CAACD,QAAQ,EAAE;MAG7D,MAAMM,eAAe,GAAGC,kBAAkB,CAAC,IAAI,CAACP,QAAQ,CAAC;MACzD,MAAMQ,mBAAmB,GAAGD,kBAAkB,CAAC,IAAI,CAACN,YAAY,CAAC;MACjE,MAAMQ,WAAW,GAAG,GAAGH,eAAe,IAAIE,mBAAmB,EAAE;MAC/D,MAAME,SAAS,GAAG1D,MAAM,CAAC2D,YAAY,CAACF,WAAW,CAAC;MAClDJ,OAAO,CAACO,aAAa,GAAG,SAASF,SAAS,EAAE;;IAG9C,OAAOL,OAAO;EAChB;EAOA,MAAMb,YAAYA,CAACL,SAAsE;IACvFrC,SAAS,CACPqC,SAAS,CAAC+C,kBAAkB,EAC5B,qEAAqE,CACtE;IACD,MAAMhF,YAAY,CAAUiC,SAAS,CAAC+C,kBAAkB,EAAE;MACxDnB,MAAM,EAAE,MAAM;MACdV,OAAO,EAAE,IAAI,CAACD,UAAU,EAAE;MAC1BY,IAAI,EAAE,IAAI,CAACnB,YAAY;KACxB,CAAC;IAEF,OAAO,IAAI;EACb;EAEAb,gBAAgBA,CAAA;IACd,OAAO;MACLgB,QAAQ,EAAE,IAAI,CAACA,QAAQ;MACvBC,YAAY,EAAE,IAAI,CAACA,YAAY;MAC/BtC,KAAK,EAAE,IAAI,CAACA,KAAK;MACjBsE,aAAa,EAAE,IAAI,CAACA;KACrB;EACH;EAEApC,YAAYA,CAAA;IACV,MAAMoB,SAAS,GAA2B;MAAEtD,KAAK,EAAE,IAAI,CAACA;IAAK,CAAE;IAC/D,IAAI,IAAI,CAACsE,aAAa,EAAE;MACtBhB,SAAS,CAACkB,eAAe,GAAG,IAAI,CAACF,aAAa;;IAGhD,IAAI,IAAI,CAACjC,QAAQ,EAAE;MACjBiB,SAAS,CAACE,SAAS,GAAG,IAAI,CAACnB,QAAQ;;IAErC,IAAI,IAAI,CAACC,YAAY,EAAE;MACrBgB,SAAS,CAACmB,aAAa,GAAG,IAAI,CAACnC,YAAY;;IAE7C,OAAOgB,SAAS;EAClB;;AAWF,OAAM,SAAUoB,iBAAiBA,CAC/BnD,MAAgC,EAChCC,SAAiE;EAEjE,MAAMC,OAAO,GAAG,IAAIkC,kBAAkB,CAACpC,MAAM,CAAC;EAC9C,OAAOE,OAAO,CAACI,YAAY,CAACL,SAAS,CAAC;AACxC;AAeA,OAAM,SAAUF,YAAYA,CAC1BC,MAAiC,EACjCC,SAAiE;EAEjE,MAAMC,OAAO,GAAG,IAAIC,mBAAmB,CAACH,MAAM,CAAC;EAC/C,OAAOE,OAAO,CAACI,YAAY,CAACL,SAAS,CAAC;AACxC;AAUA,OAAM,SAAUmD,WAAWA,CACzBpD,MAAgC,EAChCC,SAAsE;EAEtE,MAAMC,OAAO,GAAG,IAAI4C,kBAAkB,CAAC9C,MAAM,CAAC;EAC9C,OAAOE,OAAO,CAACI,YAAY,CAACL,SAAS,CAAC;AACxC;AAUA,OAAM,SAAUoD,kBAAkBA,CAChCrD,MAA0C,EAC1CC,SAAoE;EAEpE,IAAI,CAACA,SAAS,CAACqD,gBAAgB,EAAE;IAC/B,MAAM,IAAI5C,KAAK,CAAC,4EAA4E,CAAC;;EAE/F,OAAO1C,YAAY,CAAsBiC,SAAS,CAACqD,gBAAgB,EAAE;IACnEnC,OAAO,EAAE;MACP,cAAc,EAAE,mCAAmC;MACnDO,aAAa,EAAE,UAAU1B,MAAM,CAACjB,WAAW;KAC5C;IACD6C,QAAQ,EAAE,MAAM;IAChBC,MAAM,EAAE;GACT,CAAC;AACJ","ignoreList":[]},"metadata":{"hasCjsExports":false},"sourceType":"module","externalDependencies":[]}